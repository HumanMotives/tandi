<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Drummer Girl</title>

<style>
  :root{
    --w: min(1200px, 94vw);

    --tan: #e7bc8c;
    --card: #ffffff;
    --ink: #111111;
    --shadow: 0 14px 40px rgba(0,0,0,0.08);

    --red: #ff3b30;
    --blue: #3a6bff;
    --grayDot: #d9d9d9;

    --pad: 5%;

    --funGrad: linear-gradient(135deg, #ff7a18, #ff2d95, #7b61ff);
  }

  body{
    margin:0;
    min-height:100vh;
    display:grid;
    place-items:center;
    background:#fafafa;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    color:var(--ink);
  }

  /* ===== Splash ===== */
  .splash{
    position:fixed;
    inset:0;
    background:#fafafa;
    display:grid;
    place-items:center;
    z-index:9999;
  }
  .splashInner{
    width:min(560px, 86vw);
    display:grid;
    justify-items:center;
    gap:18px;
    padding:24px;
  }
  .splashLogo{
    width:min(420px, 70vw);
    height:auto;
    object-fit:contain;
    filter: drop-shadow(0 16px 30px rgba(0,0,0,0.08));
  }
  .loadingTrack{
    width:100%;
    height:18px;
    border-radius:999px;
    background:#e9e9e9;
    overflow:hidden;
    box-shadow: 0 14px 40px rgba(0,0,0,0.06);
  }
  .loadingBar{
    height:100%;
    width:0%;
    background: var(--funGrad);
    border-radius:999px;
    animation: load5 5s linear forwards;
  }
  .loadingText{
    font-weight:900;
    opacity:0.75;
    letter-spacing:0.2px;
  }
  @keyframes load5{
    0%{ width:0%; }
    12%{ width:18%; }
    30%{ width:45%; }
    60%{ width:72%; }
    82%{ width:88%; }
    100%{ width:100%; }
  }

  /* ===== App ===== */
  .app{
    width:var(--w);
    display:grid;
    gap:22px;
    padding:28px 10px 40px;
  }

  .hidden{
    display:none !important;
  }

  .top{
    display:grid;
    grid-template-columns: 1fr 1.35fr;
    gap:26px;
    align-items:center;
  }

  .logoBox{
    display:grid;
    place-items:center;
    min-height:220px;
  }

  .logoBox img{
    max-width: 520px;
    width: 100%;
    height:auto;
    object-fit:contain;
  }

  .panel{
    background: var(--tan);
    border-radius: 26px;
    padding: 26px 26px 18px;
    box-shadow: var(--shadow);
    display:grid;
    gap:18px;
  }

  .panelRow{
    display:grid;
    grid-template-columns: 70px 120px 1fr 56px;
    gap:16px;
    align-items:center;
  }

  .icon{
    width:56px;
    height:56px;
    border-radius: 14px;
    background: rgba(255,255,255,0.35);
    display:grid;
    place-items:center;
    font-size:30px;
    user-select:none;
  }

  .labelBox{
    text-align:left;
    font-weight:900;
    color: rgba(255,255,255,0.95);
    line-height:1.05;
  }

  .labelBox .small{
    display:block;
    font-weight:900;
    font-size:16px;
    opacity:0.9;
    margin-bottom:6px;
  }
  .labelBox .value{
    display:block;
    font-size:28px;
    letter-spacing: 0.2px;
  }

  input[type="range"]{
    width:100%;
    height: 22px;
    accent-color: rgba(255,255,255,0.95);
  }

  .muteBtn{
    width:56px;
    height:56px;
    border-radius: 16px;
    border: 0;
    background: rgba(255,255,255,0.35);
    color: rgba(255,255,255,0.95);
    cursor:pointer;
    display:grid;
    place-items:center;
    font-size:24px;
  }

  .muteBtn:active{ transform: scale(0.98); }
  .muteBtn.isMuted{
    background: rgba(0,0,0,0.18);
    color: rgba(255,255,255,0.95);
  }

  .panelActions{
    display:flex;
    gap:14px;
    justify-content:flex-end;
    padding-top:4px;
  }

  .btn{
    border:0;
    cursor:pointer;
    font-weight:900;
    padding: 14px 20px;
    border-radius: 18px;
    font-size:18px;
    min-width: 120px;
    box-shadow: 0 10px 22px rgba(0,0,0,0.10);
  }

  .btn.play{ background:#111; color:#fff; }
  .btn.stop{ background: rgba(255,255,255,0.75); color:#111; }
  .btn:disabled{
    opacity:0.55;
    cursor:not-allowed;
    box-shadow:none;
  }

  .rewardLane{
    display:flex;
    align-items:center;
    justify-content:center;
    gap:10px;
    margin-top:6px;
    padding: 8px 0 0;
    color: rgba(255,255,255,0.95);
    font-weight: 950;
  }
  .rewardLane .star{
    font-size: 30px;
    filter: drop-shadow(0 10px 18px rgba(0,0,0,0.12));
  }
  .rewardLane .text{
    font-size: 16px;
    opacity: 0.95;
    letter-spacing: 0.2px;
  }

  .stage{
    display:grid;
    grid-template-columns: 1fr;
    gap:14px;
    align-items:center;
  }

  .seqWrap{
    display:grid;
    grid-template-columns: 1fr auto;
    gap:18px;
    align-items:start;
  }

  .leftStack{
    display:grid;
    grid-template-rows: 180px auto;
    gap:10px;
  }

  .sequencer{
    position:relative;
    width:100%;
    height: 180px;
    background: var(--card);
    border: 2px solid #ededed;
    border-radius: 26px;
    box-shadow: var(--shadow);
    overflow:hidden;
  }

  .line{
    position:absolute;
    left: var(--pad);
    right: var(--pad);
    top: 50%;
    height: 8px;
    transform: translateY(-50%);
    background: #e6e6e6;
    border-radius: 999px;
  }

  .step{
    position:absolute;
    top: 50%;
    transform: translate(-50%, -50%);
    border-radius: 999px;
  }

  .step.inactive{
    width: 18px;
    height: 18px;
    background: var(--grayDot);
  }

  .step.active{
    width: 44px;
    height: 44px;
    border: 3px solid #fff;
    box-shadow: 0 10px 22px rgba(0,0,0,0.12);
  }

  .step.handR{ background: var(--red); }
  .step.handL{ background: var(--blue); }

  .step.pop{ animation: pop 170ms ease-out; }

  @keyframes pop{
    0%{ transform: translate(-50%, -50%) scale(1); }
    60%{ transform: translate(-50%, -50%) scale(1.35); }
    100%{ transform: translate(-50%, -50%) scale(1); }
  }

  .step.current{
    box-shadow:
      0 0 0 6px rgba(0,0,0,0.10),
      0 14px 26px rgba(0,0,0,0.10);
  }
  .step.inactive.current{
    box-shadow:
      0 0 0 6px rgba(0,0,0,0.10);
  }

  .multiplierWrap{
    position: relative;
    width: 140px;
    height: 180px;
    display:grid;
    place-items:center;
    align-self:start;
  }

  .multiplier{
    width: 140px;
    height: 180px;
    border-radius: 26px;
    background: var(--funGrad);
    color:#fff;
    display:grid;
    place-items:center;
    box-shadow: var(--shadow);
    overflow:hidden;
  }

  .multiplier::after{
    content:"";
    position:absolute;
    inset:0;
    background: radial-gradient(circle at 30% 20%, rgba(255,255,255,0.22), transparent 45%);
    pointer-events:none;
  }

  .multiplier span{
    font-size: 56px;
    font-weight: 950;
    letter-spacing: 1px;
    text-shadow: 0 10px 22px rgba(0,0,0,0.20);
  }

  .multiplier.sparklePulse{
    animation: pulse 450ms ease-out;
  }
  @keyframes pulse{
    0%{ transform: scale(1); }
    35%{ transform: scale(1.05); }
    100%{ transform: scale(1); }
  }

  .sparkleLayer{
    position:absolute;
    inset:0;
    pointer-events:none;
    overflow:visible;
  }

  .spark{
    position:absolute;
    left:50%;
    top:50%;
    transform: translate(-50%,-50%);
    font-size: 22px;
    filter: drop-shadow(0 10px 18px rgba(0,0,0,0.22));
    animation: fly 900ms ease-out forwards;
    opacity: 0;
  }

  @keyframes fly{
    0%   { opacity:0; transform: translate(-50%,-50%) scale(0.85); }
    10%  { opacity:1; }
    100% { opacity:0; transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) scale(1.25); }
  }

  .handRow{
    width: 100%;
    display:grid;
    grid-template-columns: repeat(8, 1fr);
    gap: 12px;
    justify-items:center;
    align-items:start;
    padding-top: 6px;
  }

  .handCell{
    min-height: 76px;
    display:grid;
    gap: 6px;
    justify-items:center;
    align-content:start;
    font-weight: 900;
    font-size: 24px;
  }

  .handCell .handIcon{
    font-size: 34px;
    line-height:1;
  }

  .handCell.R{ color: var(--red); }
  .handCell.L{ color: var(--blue); }

  .handRow.hidden{
    display:none;
  }

  @media (max-width: 980px){
    .top{ grid-template-columns: 1fr; }
    .logoBox{ min-height: 160px; }
    .panelRow{ grid-template-columns: 60px 120px 1fr 56px; }
    .multiplierWrap{ width: 120px; }
    .multiplier{ width: 120px; }
  }
</style>
</head>

<body>

  <!-- Splash screen -->
  <div class="splash" id="splash">
    <div class="splashInner">
      <img class="splashLogo" src="/drummergirl/logo.png" alt="Drummer Girl" />
      <div class="loadingTrack" aria-label="Loading">
        <div class="loadingBar"></div>
      </div>
      <div class="loadingText">Loading drums‚Ä¶</div>
    </div>
  </div>

  <!-- Main app -->
  <div class="app hidden" id="app">

    <div class="top">
      <div class="logoBox">
        <img src="/drummergirl/logo.png" alt="Drummer Girl Logo" />
      </div>

      <div>
        <div class="panel">
          <div class="panelRow">
            <div class="icon">üéµ</div>
            <div class="labelBox">
              <span class="small">BPM:</span>
              <span class="value" id="bpmValue">120</span>
            </div>
            <input id="bpmSlider" type="range" min="50" max="200" value="120" />
            <button id="metroMuteBtn" class="muteBtn" title="Mute metronome">üîä</button>
          </div>

          <div class="panelRow">
            <div class="icon">ü•Å</div>
            <div class="labelBox">
              <span class="small">HITS:</span>
              <span class="value"><span id="hitsValue">4</span>/<span>8</span></span>
            </div>
            <input id="hitsSlider" type="range" min="1" max="8" value="4" />
            <button id="hitsMuteBtn" class="muteBtn" title="Mute hits">üîä</button>
          </div>

          <div class="panelRow" style="opacity:0.9;">
            <div class="icon">‚úã</div>
            <div class="labelBox">
              <span class="small">HANDS:</span>
              <span class="value" style="font-size:22px;">SHOW</span>
            </div>
            <input id="handsStrength" type="range" min="0" max="100" value="100" />
            <button id="handsToggleBtn" class="muteBtn" title="Toggle hands row">üëÄ</button>
          </div>

          <div class="panelActions">
            <button id="playBtn" class="btn play">Play</button>
            <button id="stopBtn" class="btn stop" disabled>Stop</button>
          </div>
        </div>

        <div class="rewardLane" aria-label="Reward lane">
          <div class="star">‚≠ê</div>
          <div class="text">Practice Stars</div>
        </div>
      </div>
    </div>

    <div class="stage">
      <div class="seqWrap">

        <div class="leftStack">
          <div class="sequencer" id="sequencer">
            <div class="line"></div>
          </div>
          <div class="handRow hidden" id="handRow"></div>
        </div>

        <div class="multiplierWrap">
          <div class="multiplier" id="multiplier">
            <span id="barText">X0</span>
          </div>
          <div class="sparkleLayer" id="sparkleLayer"></div>
        </div>

      </div>
    </div>

  </div>

<script>
  // ===== Splash behavior =====
  const splash = document.getElementById("splash");
  const appEl  = document.getElementById("app");

  // Show splash for 5 seconds then reveal app
  setTimeout(() => {
    splash.classList.add("hidden");
    appEl.classList.remove("hidden");
  }, 5000);

  // ===== Core =====
  const STEPS = 8;

  const sequencer = document.getElementById("sequencer");
  const handRow   = document.getElementById("handRow");

  const multiplier = document.getElementById("multiplier");
  const barText   = document.getElementById("barText");
  const sparkleLayer = document.getElementById("sparkleLayer");

  const bpmSlider = document.getElementById("bpmSlider");
  const bpmValue  = document.getElementById("bpmValue");

  const hitsSlider = document.getElementById("hitsSlider");
  const hitsValue  = document.getElementById("hitsValue");

  const playBtn = document.getElementById("playBtn");
  const stopBtn = document.getElementById("stopBtn");

  const metroMuteBtn = document.getElementById("metroMuteBtn");
  const hitsMuteBtn  = document.getElementById("hitsMuteBtn");

  const handsToggleBtn = document.getElementById("handsToggleBtn");
  const handsStrength = document.getElementById("handsStrength");

  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  let metronomeMuted = false;
  let hitsMuted = false;

  // Bar start alternates pitch each bar
  let barStartFlip = false;

  // Metronome will tick ONLY on quarter notes: steps 0,2,4,6
  function isQuarterStep(stepIndex){
    return stepIndex === 0 || stepIndex === 2 || stepIndex === 4 || stepIndex === 6;
  }

  // force=true: used for count-in even if metronome is muted
  function metroTick(stepIndex, force=false){
    if (metronomeMuted && !force) return;
    if (!isQuarterStep(stepIndex)) return;

    const isBarStart = (stepIndex === 0);

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = "square";

    const barStartFreqA = 1600;
    const barStartFreqB = 1900;
    const quarterSoftFreq = 850;

    const freq = isBarStart ? (barStartFlip ? barStartFreqA : barStartFreqB) : quarterSoftFreq;
    osc.frequency.value = freq;

    const now = audioCtx.currentTime;
    const peak = isBarStart ? 0.22 : 0.09;
    const dur  = isBarStart ? 0.055 : 0.045;

    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(peak, now + 0.002);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);

    osc.connect(gain);
    gain.connect(audioCtx.destination);

    osc.start(now);
    osc.stop(now + dur + 0.01);
  }

  function hitTick(){
    if (hitsMuted) return;

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type = "triangle";
    osc.frequency.value = 620;

    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(0.16, now + 0.002);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.03);

    osc.connect(gain);
    gain.connect(audioCtx.destination);

    osc.start(now);
    osc.stop(now + 0.04);
  }

  function updateMuteButton(btn, muted){
    btn.textContent = muted ? "üîá" : "üîä";
    btn.classList.toggle("isMuted", muted);
  }

  function euclidean(steps, pulses) {
    const pattern = new Array(steps).fill(0);
    for (let i = 0; i < steps; i++) {
      const v = Math.floor((i * pulses) / steps) !== Math.floor(((i - 1) * pulses) / steps);
      pattern[i] = v ? 1 : 0;
    }
    const count = pattern.reduce((a,b)=>a+b,0);
    if (count !== pulses) {
      pattern.fill(0);
      for (let k=0;k<pulses;k++) pattern[k]=1;
    }
    return pattern;
  }

  function handsAlternateFromR(hitsArr){
    const hands = new Array(STEPS).fill(null);
    let next = "R";
    for (let i=0;i<STEPS;i++){
      if (hitsArr[i]) {
        hands[i] = next;
        next = (next === "R") ? "L" : "R";
      }
    }
    return hands;
  }

  let stepEls = [];
  let currentHits = new Array(STEPS).fill(0);
  let currentHands = new Array(STEPS).fill(null);

  let currentStepIndex = -1;

  function setCurrentStep(i){
    if (currentStepIndex >= 0 && stepEls[currentStepIndex]) {
      stepEls[currentStepIndex].classList.remove("current");
    }
    currentStepIndex = i;
    if (currentStepIndex >= 0 && stepEls[currentStepIndex]) {
      stepEls[currentStepIndex].classList.add("current");
    }
  }

  function popStep(i){
    const el = stepEls[i];
    if (!el) return;
    if (!el.classList.contains("active")) return;

    el.classList.remove("pop");
    void el.offsetWidth;
    el.classList.add("pop");
  }

  function buildSequencer(){
    const keep = Array.from(sequencer.querySelectorAll(".line"));
    sequencer.innerHTML = "";
    keep.forEach(el => sequencer.appendChild(el));

    stepEls = [];

    const pulses = Number(hitsSlider.value);
    currentHits = euclidean(STEPS, pulses);
    currentHands = handsAlternateFromR(currentHits);

    const width = sequencer.clientWidth;
    const leftPad = width * 0.05;
    const rightPad = width * 0.95;
    const usable = rightPad - leftPad;

    for (let i=0;i<STEPS;i++){
      const isActive = currentHits[i] === 1;
      const hand = currentHands[i];

      const step = document.createElement("div");
      step.classList.add("step");

      if (isActive){
        step.classList.add("active");
        step.classList.add(hand === "R" ? "handR" : "handL");
      } else {
        step.classList.add("inactive");
      }

      const norm = i / STEPS;
      const x = leftPad + norm * usable;
      step.style.left = `${x}px`;

      sequencer.appendChild(step);
      stepEls.push(step);
    }

    buildHandRow();
    setCurrentStep(-1);
  }

  function buildHandRow(){
    handRow.innerHTML = "";

    for (let i=0;i<STEPS;i++){
      const cell = document.createElement("div");
      cell.classList.add("handCell");

      const isActive = currentHits[i] === 1;
      const h = currentHands[i];

      if (!isActive || !h){
        cell.innerHTML = `<div style="height:24px;"></div><div style="height:34px;"></div>`;
      } else {
        cell.classList.add(h);
        cell.innerHTML = `<div>${h}</div><div class="handIcon">‚úã</div>`;
      }

      handRow.appendChild(cell);
    }

    const strength = Number(handsStrength.value) / 100;
    handRow.style.opacity = String(strength);
  }

  let handsVisible = false; // default off
  function setHandsVisible(visible){
    handsVisible = visible;
    handRow.classList.toggle("hidden", !visible);
  }

  function sparkleBurst(){
    multiplier.classList.remove("sparklePulse");
    void multiplier.offsetWidth;
    multiplier.classList.add("sparklePulse");

    const count = 18;
    for (let i=0;i<count;i++){
      const s = document.createElement("div");
      s.className = "spark";
      s.textContent = "‚≠ê";

      const angle = Math.random() * Math.PI * 2;
      const dist = 40 + Math.random() * 70;
      const dx = Math.cos(angle) * dist;
      const dy = Math.sin(angle) * dist;

      s.style.setProperty("--dx", dx.toFixed(1) + "px");
      s.style.setProperty("--dy", dy.toFixed(1) + "px");
      s.style.fontSize = (18 + Math.random()*14).toFixed(0) + "px";

      sparkleLayer.appendChild(s);
      setTimeout(() => s.remove(), 1000);
    }
  }

  // ===== Playback (timeline-driven handoff) =====
  let bpm = Number(bpmSlider.value);
  let isPlaying = false;
  let rafId = null;

  let barCount = 0;

  // Groove timeline
  let grooveStartPerf = null;   // planned start time (perf ms)
  let lastStepCount = -1;
  let grooveStarted = false;

  // Count-in scheduling
  let countInActive = false;
  let countInTimeouts = [];

  function beatMs(){ return 60000 / bpm; }
  function barMs(){ return beatMs() * 4; }
  function stepDurMs(){ return barMs() / STEPS; } // still 8-step grid for hits + dot cursor

  function updateBarText(){
    barText.textContent = `X${barCount}`;
  }

  function resetPlaybackState(){
    grooveStartPerf = null;
    lastStepCount = -1;
    grooveStarted = false;

    barCount = 0;
    updateBarText();
    setCurrentStep(-1);
  }

  function clearCountIn(){
    countInTimeouts.forEach(id => clearTimeout(id));
    countInTimeouts = [];
    countInActive = false;
  }

  // Schedule 4 count-in clicks on quarter notes (always audible), and compute exact groove start.
  function scheduleCountInAndGrooveStart(){
    countInActive = true;

    const now = performance.now();
    const offset = 80;                 // small offset to avoid "immediate click" scheduling jitter
    const start = now + offset;        // count-in click #1 time
    const ms = beatMs();

    // Clear any old timeouts
    clearCountIn();
    countInActive = true;

    // Schedule 4 quarter clicks: t0, t1, t2, t3
    for (let n = 0; n < 4; n++){
      const tClick = start + n * ms;
      const delay = Math.max(0, tClick - performance.now());
      const id = setTimeout(() => {
        // First click accented, rest soft. Always force audible.
        if (n === 0) metroTick(0, true);
        else metroTick(2, true); // any quarter step index works for soft; we just want the soft pitch
      }, delay);
      countInTimeouts.push(id);
    }

    // Groove should start exactly on the NEXT downbeat after the 4th click:
    // clicks are beats 1..4, groove begins on beat 1 of next bar
    grooveStartPerf = start + 4 * ms;

    // End count-in state right before groove start
    const doneDelay = Math.max(0, grooveStartPerf - performance.now());
    const doneId = setTimeout(() => {
      countInActive = false;
    }, doneDelay);
    countInTimeouts.push(doneId);
  }

  function triggerStep(stepIndex){
    setCurrentStep(stepIndex);

    // Quarter-note metronome only
    metroTick(stepIndex, false);

    // Active hits always (unless muted)
    if (currentHits[stepIndex] === 1){
      popStep(stepIndex);
      hitTick();
    }
  }

  function frame(t){
    if (!isPlaying) return;

    // Wait until planned groove start, then begin
    if (!grooveStarted){
      if (grooveStartPerf !== null && t >= grooveStartPerf){
        grooveStarted = true;

        // Initialize counters so the first computed step is 0
        lastStepCount = -1;

        // Immediately fire step 0 right on the downbeat boundary
        triggerStep(0);
        lastStepCount = 0;
      }

      rafId = requestAnimationFrame(frame);
      return;
    }

    // We are in groove: compute stepCount from planned grooveStartPerf
    const elapsed = t - grooveStartPerf;
    const sDur = stepDurMs();
    const stepCount = Math.floor(elapsed / sDur);

    if (stepCount > lastStepCount){
      for (let sc = lastStepCount + 1; sc <= stepCount; sc++){
        const stepIndex = ((sc % STEPS) + STEPS) % STEPS;

        // Every full bar
        if (sc > 0 && sc % STEPS === 0){
          barCount += 1;
          updateBarText();

          barStartFlip = !barStartFlip;

          if (barCount % 8 === 0) sparkleBurst();
        }

        // Avoid double-triggering step 0 at start (we already fired it)
        if (sc === 0) continue;

        triggerStep(stepIndex);
      }
      lastStepCount = stepCount;
    }

    rafId = requestAnimationFrame(frame);
  }

  function setBpm(newBpm){
    bpm = newBpm;

    // If playing and groove already started, preserve phase
    if (isPlaying && grooveStarted && grooveStartPerf !== null){
      const now = performance.now();
      const elapsed = now - grooveStartPerf;

      // compute phase in old step duration
      const oldStep = stepDurMs(); // uses bpm, but bpm already updated. So we need old bpm for true phase.
      // Quick pragmatic approach: stop phase preservation while playing. It's fine for now.
      // We can rebuild this later with explicit division setting.

      // For now: restart timing reference so it doesn‚Äôt ‚Äújump‚Äù badly.
      grooveStartPerf = now - elapsed;
      lastStepCount = Math.floor((now - grooveStartPerf) / stepDurMs());
    }
  }

  async function play(){
    if (isPlaying || countInActive) return;
    isPlaying = true;

    await audioCtx.resume();

    playBtn.disabled = true;
    stopBtn.disabled = false;

    resetPlaybackState();

    // Schedule count-in and compute exact groove start time
    scheduleCountInAndGrooveStart();

    rafId = requestAnimationFrame(frame);
  }

  function stop(){
    clearCountIn();

    isPlaying = false;

    playBtn.disabled = false;
    stopBtn.disabled = true;

    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;

    resetPlaybackState();
  }

  // ===== UI wiring =====
  bpmValue.textContent = bpmSlider.value;
  hitsValue.textContent = hitsSlider.value;

  bpmSlider.addEventListener("input", (e)=>{
    const val = Number(e.target.value);
    bpmValue.textContent = String(val);
    setBpm(val);
  });

  hitsSlider.addEventListener("input", (e)=>{
    hitsValue.textContent = e.target.value;
    buildSequencer();
  });

  playBtn.addEventListener("click", play);
  stopBtn.addEventListener("click", stop);

  metroMuteBtn.addEventListener("click", ()=>{
    metronomeMuted = !metronomeMuted;
    updateMuteButton(metroMuteBtn, metronomeMuted);
  });

  hitsMuteBtn.addEventListener("click", ()=>{
    hitsMuted = !hitsMuted;
    updateMuteButton(hitsMuteBtn, hitsMuted);
  });

  handsToggleBtn.addEventListener("click", ()=>{
    setHandsVisible(!handsVisible);
  });

  handsStrength.addEventListener("input", buildHandRow);
  window.addEventListener("resize", buildSequencer);

  // init
  updateMuteButton(metroMuteBtn, metronomeMuted);
  updateMuteButton(hitsMuteBtn, hitsMuted);

  setHandsVisible(false);
  buildSequencer();
  stop();
</script>
</body>
</html>
