<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Drum School Lesson Editor</title>

  <!-- Hergebruik je bestaande knoppen/fonts indien gewenst -->
  <link rel="stylesheet" href="/styles/styles.css" />

  <style>
    .leWrap{
      width: min(1200px, 94vw);
      margin: 0 auto;
      padding: 18px;
      box-sizing: border-box;
      display: grid;
      gap: 14px;
    }

    .leGrid{
      display: grid;
      grid-template-columns: 440px 1fr;
      gap: 14px;
      align-items: start;
    }

    @media (max-width: 980px){
      .leGrid{ grid-template-columns: 1fr; }
    }

    .leCard{
      border: 4px solid rgba(20,20,24,0.95);
      border-radius: 18px;
      background: rgba(255,255,255,0.70);
      box-shadow: 0 10px 0 rgba(0,0,0,0.10);
      padding: 14px;
    }

    .leTitle{
      font-family: var(--font-display, system-ui);
      font-size: 22px;
      margin: 0 0 10px 0;
    }

    .leRow{
      display: grid;
      grid-template-columns: 160px 1fr;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }

    .leRow label{
      font-weight: 900;
      opacity: 0.9;
    }

    .leInput, .leSelect, .leTextarea{
      width: 100%;
      border: 4px solid rgba(20,20,24,0.95);
      border-radius: 16px;
      background: rgba(255,255,255,0.85);
      box-shadow: 0 10px 0 rgba(0,0,0,0.08);
      padding: 10px 12px;
      font-weight: 900;
      outline: none;
      box-sizing: border-box;
    }

    .leTextarea{
      min-height: 44px;
      resize: vertical;
      font-weight: 800;
    }

    .leChecks{
      display: grid;
      gap: 8px;
      margin: 8px 0 0 0;
    }

    .leCheck{
      display: flex;
      gap: 10px;
      align-items: center;
      font-weight: 900;
    }

    .leCheck input{
      width: 18px;
      height: 18px;
    }

    .leActions{
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 12px;
      justify-content: flex-end;
    }

    /* Pattern editor */
    .peHeader{
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .barTabs{
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .barTab{
      border: 4px solid rgba(20,20,24,0.95);
      border-radius: 999px;
      background: rgba(255,255,255,0.75);
      box-shadow: 0 10px 0 rgba(0,0,0,0.10);
      padding: 8px 12px;
      cursor: pointer;
      font-weight: 900;
      line-height: 1;
      user-select: none;
    }

    .barTab.isActive{
      background: rgba(255,224,106,0.85);
    }

    .stepGrid{
      --cols: 8;
      display: grid;
      grid-template-columns: repeat(var(--cols), minmax(0, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .stepCell{
      border: 4px solid rgba(20,20,24,0.95);
      border-radius: 16px;
      background: rgba(255,255,255,0.75);
      box-shadow: 0 10px 0 rgba(0,0,0,0.10);
      padding: 10px 8px;
      cursor: pointer;
      user-select: none;
      display: grid;
      gap: 6px;
      justify-items: center;
      text-align: center;
    }

    .stepDot{
      width: 18px;
      height: 18px;
      border-radius: 999px;
      background: rgba(20,20,24,0.18);
    }

    .stepCell.isHit .stepDot{
      background: rgba(20,20,24,0.90);
    }

    .handPicker{
      display: flex;
      gap: 6px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .handBtn{
      border: 3px solid rgba(20,20,24,0.95);
      border-radius: 999px;
      background: rgba(255,255,255,0.75);
      padding: 6px 10px;
      cursor: pointer;
      font-weight: 900;
      line-height: 1;
      font-size: 14px;
    }

    .handBtn.isActive{
      background: rgba(240,230,255,0.92);
    }

    .leJsonBox{
      width: 100%;
      border: 4px solid rgba(20,20,24,0.95);
      border-radius: 16px;
      background: rgba(255,255,255,0.90);
      padding: 12px;
      box-sizing: border-box;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      line-height: 1.4;
      min-height: 260px;
      white-space: pre;
      overflow: auto;
    }

    .miniNote{
      font-size: 12px;
      opacity: 0.8;
      font-weight: 800;
      margin-top: 6px;
    }

    .btnRowLeft{
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
  </style>
</head>

<body>
  <div class="leWrap">
    <div class="leCard">
      <h1 class="leTitle">Lesson Editor (JSON generator)</h1>
      <div class="miniNote">
        Tip: zet <b>Stappen per maat</b> op <b>4</b> voor je eerste lessen. Dan is elk stipje een metronoom-tik.
      </div>
    </div>

    <div class="leGrid">
      <!-- LEFT: Form -->
      <div class="leCard">
        <h2 class="leTitle">Basis</h2>

        <div class="leRow">
          <label for="leLessonId">Lesson ID</label>
          <input id="leLessonId" class="leInput" placeholder="W1-L1" />
        </div>

        <div class="leRow">
          <label for="leWorldId">World ID</label>
          <input id="leWorldId" class="leInput" placeholder="W1" />
        </div>

        <div class="leRow">
          <label for="leTitle">Titel</label>
          <input id="leTitle" class="leInput" placeholder="Klap mee in de maat" />
        </div>

        <div class="leRow">
          <label for="leBpm">BPM</label>
          <input id="leBpm" class="leInput" type="number" min="40" max="220" />
        </div>

        <div class="leRow">
          <label for="leBars">Aantal bars</label>
          <input id="leBars" class="leInput" type="number" min="1" max="64" />
        </div>

        <div class="leRow">
          <label for="leStepsPerBar">Stappen/maat</label>
          <select id="leStepsPerBar" class="leSelect">
            <option value="4">4 (quarter grid)</option>
            <option value="8">8 (eighth grid)</option>
            <option value="16">16 (sixteenth grid)</option>
          </select>
        </div>

        <h2 class="leTitle" style="margin-top:14px;">UI opties</h2>
        <div class="leChecks">
          <label class="leCheck"><input type="checkbox" id="uiMetronome" /> Metronoom toggle</label>
          <label class="leCheck"><input type="checkbox" id="uiBpm" /> BPM slider</label>
          <label class="leCheck"><input type="checkbox" id="uiHits" /> Hits slider</label>
          <label class="leCheck"><input type="checkbox" id="uiHands" /> Hands UI</label>
          <label class="leCheck"><input type="checkbox" id="uiPlayStop" /> Start/Stop knoppen</label>
        </div>

        <h2 class="leTitle" style="margin-top:14px;">Tutorial teksten (leeg = skip)</h2>
        <div class="leRow">
          <label for="t1">Tekst 1</label>
          <textarea id="t1" class="leTextarea" placeholder="..."></textarea>
        </div>
        <div class="leRow">
          <label for="t2">Tekst 2</label>
          <textarea id="t2" class="leTextarea" placeholder="..."></textarea>
        </div>
        <div class="leRow">
          <label for="t3">Tekst 3</label>
          <textarea id="t3" class="leTextarea" placeholder="..."></textarea>
        </div>
        <div class="leRow">
          <label for="t4">Tekst 4</label>
          <textarea id="t4" class="leTextarea" placeholder="..."></textarea>
        </div>
        <div class="leRow" style="margin-bottom:0;">
          <label for="t5">Tekst 5</label>
          <textarea id="t5" class="leTextarea" placeholder="..."></textarea>
        </div>

        <div class="leActions">
          <button class="btn ghost" type="button" id="btnNew">Nieuw</button>
          <button class="btn ghost" type="button" id="btnSave">Opslaan (local)</button>
          <button class="btn ghost" type="button" id="btnLoad">Laden (local)</button>
          <button class="btn ghost" type="button" id="btnImport">Import JSON</button>
        </div>
      </div>

      <!-- RIGHT: Pattern + JSON -->
      <div class="leCard">
        <div class="peHeader">
          <div class="btnRowLeft">
            <h2 class="leTitle" style="margin:0;">Pattern</h2>
            <button class="btn ghost" type="button" id="btnFillQuarter">Vul kwartnoten</button>
            <button class="btn ghost" type="button" id="btnClearBar">Wis bar</button>
          </div>

          <div class="leActions" style="margin:0;">
            <button class="btn ghost" type="button" id="btnExport">Refresh JSON</button>
            <button class="btn ghost" type="button" id="btnCopy">Kopieer</button>
            <button class="btn primary" type="button" id="btnDownload">Download .json</button>
          </div>
        </div>

        <div class="barTabs" id="barTabs"></div>
        <div class="stepGrid" id="stepGrid"></div>

        <h2 class="leTitle" style="margin-top:14px;">Export JSON</h2>
        <div class="leJsonBox" id="jsonBox"></div>
      </div>
    </div>
  </div>

<script>
  const STORAGE_KEY = "dsLessonEditor.v2";

  const el = {
    lessonId: byId("leLessonId"),
    worldId: byId("leWorldId"),
    title: byId("leTitle"),
    bpm: byId("leBpm"),
    bars: byId("leBars"),
    stepsPerBar: byId("leStepsPerBar"),

    uiMetronome: byId("uiMetronome"),
    uiBpm: byId("uiBpm"),
    uiHits: byId("uiHits"),
    uiHands: byId("uiHands"),
    uiPlayStop: byId("uiPlayStop"),

    t1: byId("t1"),
    t2: byId("t2"),
    t3: byId("t3"),
    t4: byId("t4"),
    t5: byId("t5"),

    btnNew: byId("btnNew"),
    btnSave: byId("btnSave"),
    btnLoad: byId("btnLoad"),
    btnImport: byId("btnImport"),

    btnFillQuarter: byId("btnFillQuarter"),
    btnClearBar: byId("btnClearBar"),

    btnExport: byId("btnExport"),
    btnCopy: byId("btnCopy"),
    btnDownload: byId("btnDownload"),

    barTabs: byId("barTabs"),
    stepGrid: byId("stepGrid"),
    jsonBox: byId("jsonBox")
  };

  let state = loadInitialState();

  hydrateFormFromState();
  ensurePatternSize();
  renderBarTabs();
  renderStepGrid();
  renderJson();

  // Form wiring
  [
    el.lessonId, el.worldId, el.title, el.bpm, el.bars
  ].forEach(inp => inp.addEventListener("input", onFormChange));

  el.stepsPerBar.addEventListener("change", () => {
    state.stepsPerBar = clampInt(el.stepsPerBar.value, 4, 16);
    if (![4,8,16].includes(state.stepsPerBar)) state.stepsPerBar = 4;

    // Rebuild all bars with new size (keep what we can)
    remapPatternToSteps(state.stepsPerBar);
    ensurePatternSize();
    renderBarTabs();
    renderStepGrid();
    renderJson();
  });

  [
    el.uiMetronome, el.uiBpm, el.uiHits, el.uiHands, el.uiPlayStop
  ].forEach(chk => chk.addEventListener("change", onFormChange));

  [el.t1, el.t2, el.t3, el.t4, el.t5].forEach(t => t.addEventListener("input", onFormChange));

  function onFormChange(){
    state.lessonId = String(el.lessonId.value || "").trim();
    state.worldId = String(el.worldId.value || "").trim();
    state.title = String(el.title.value || "").trim();

    state.bpm = clampInt(el.bpm.value, 40, 220);
    state.bars = clampInt(el.bars.value, 1, 64);

    state.ui.showMetronome = !!el.uiMetronome.checked;
    state.ui.showBpm = !!el.uiBpm.checked;
    state.ui.showHits = !!el.uiHits.checked;
    state.ui.showHands = !!el.uiHands.checked;
    state.ui.showPlayStop = !!el.uiPlayStop.checked;

    state.tutorial = [
      el.t1.value || "",
      el.t2.value || "",
      el.t3.value || "",
      el.t4.value || "",
      el.t5.value || ""
    ];

    ensurePatternSize();
    if (state.activeBar >= state.bars) state.activeBar = state.bars - 1;

    renderBarTabs();
    renderStepGrid();
    renderJson();
  }

  // Actions
  el.btnNew.addEventListener("click", () => {
    state = makeDefaultState();
    hydrateFormFromState();
    ensurePatternSize();
    renderBarTabs();
    renderStepGrid();
    renderJson();
  });

  el.btnSave.addEventListener("click", () => {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    toast("Opgeslagen in localStorage.");
  });

  el.btnLoad.addEventListener("click", () => {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) { toast("Geen opgeslagen editor data gevonden."); return; }
    try{
      state = JSON.parse(raw);
      state = normalizeState(state);
      hydrateFormFromState();
      ensurePatternSize();
      renderBarTabs();
      renderStepGrid();
      renderJson();
      toast("Geladen.");
    }catch{
      toast("Kon opgeslagen data niet laden.");
    }
  });

  el.btnExport.addEventListener("click", () => {
    renderJson(true);
    toast("JSON is up-to-date.");
  });

  el.btnCopy.addEventListener("click", async () => {
    const json = JSON.stringify(buildLessonConfig(), null, 2);
    try{
      await navigator.clipboard.writeText(json);
      toast("Gekopieerd naar klembord.");
    }catch{
      toast("KopiÃ«ren lukte niet. Selecteer en kopieer handmatig.");
    }
  });

  el.btnDownload.addEventListener("click", () => {
    const json = JSON.stringify(buildLessonConfig(), null, 2);
    const name = (state.lessonId || "lesson").replaceAll(" ", "-");
    const blob = new Blob([json], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${name}.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  el.btnImport.addEventListener("click", () => {
    const pasted = prompt("Plak hier een lesson JSON (export):");
    if (!pasted) return;
    try{
      const obj = JSON.parse(pasted);
      state = stateFromLessonConfig(obj);
      state = normalizeState(state);
      hydrateFormFromState();
      ensurePatternSize();
      renderBarTabs();
      renderStepGrid();
      renderJson();
      toast("Import gelukt.");
    }catch{
      toast("Import mislukt. JSON niet geldig.");
    }
  });

  el.btnFillQuarter.addEventListener("click", () => {
    const b = state.activeBar;
    clearBar(b);

    const spb = state.stepsPerBar;
    const idxs =
      spb === 4 ? [0,1,2,3] :
      spb === 8 ? [0,2,4,6] :
      [0,4,8,12];

    idxs.forEach(i => setHit(b, i, true));
    autoHandsAlternate(b);

    renderStepGrid();
    renderJson();
  });

  el.btnClearBar.addEventListener("click", () => {
    clearBar(state.activeBar);
    renderStepGrid();
    renderJson();
  });

  // Rendering
  function renderBarTabs(){
    el.barTabs.innerHTML = "";
    for (let i=0;i<state.bars;i++){
      const btn = document.createElement("div");
      btn.className = "barTab" + (i === state.activeBar ? " isActive" : "");
      btn.textContent = `Bar ${i+1}`;
      btn.addEventListener("click", () => {
        state.activeBar = i;
        renderBarTabs();
        renderStepGrid();
      });
      el.barTabs.appendChild(btn);
    }
  }

  function renderStepGrid(){
    const b = state.activeBar;
    const spb = state.stepsPerBar;

    el.stepGrid.style.setProperty("--cols", String(spb));
    el.stepGrid.innerHTML = "";

    for (let s=0; s<spb; s++){
      const cell = document.createElement("div");
      const isHit = !!state.pattern[b].hits[s];
      cell.className = "stepCell" + (isHit ? " isHit" : "");

      const dot = document.createElement("div");
      dot.className = "stepDot";

      const label = document.createElement("div");
      label.style.fontWeight = "900";
      label.style.opacity = "0.85";
      label.textContent = `${s+1}`;

      const handWrap = document.createElement("div");
      handWrap.className = "handPicker";

      const hand = state.pattern[b].hands[s] || "";

      const makeHandBtn = (val, text) => {
        const hb = document.createElement("button");
        hb.type = "button";
        hb.className = "handBtn" + (hand === val ? " isActive" : "");
        hb.textContent = text;
        hb.addEventListener("click", (e) => {
          e.stopPropagation();
          if (!state.pattern[b].hits[s]) {
            setHit(b, s, true);
          }
          setHand(b, s, val);
          renderStepGrid();
          renderJson();
        });
        return hb;
      };

      handWrap.appendChild(makeHandBtn("", "Geen"));
      handWrap.appendChild(makeHandBtn("R", "R"));
      handWrap.appendChild(makeHandBtn("L", "L"));

      cell.appendChild(dot);
      cell.appendChild(label);
      cell.appendChild(handWrap);

      cell.addEventListener("click", () => {
        const next = !state.pattern[b].hits[s];
        setHit(b, s, next);
        if (!next) setHand(b, s, "");
        renderStepGrid();
        renderJson();
      });

      el.stepGrid.appendChild(cell);
    }
  }

  function renderJson(force){
    const json = JSON.stringify(buildLessonConfig(), null, 2);
    el.jsonBox.textContent = json;
    if (force) el.jsonBox.scrollTop = 0;
  }

  // Build config the game will use
  function buildLessonConfig(){
    const intro = (state.tutorial || [])
      .map(s => String(s || "").trim())
      .filter(Boolean)
      .map(text => ({ text }));

    const spb = state.stepsPerBar;

    // Pattern per bar: hits = [indices], hands = [R/L/"" aligned to hits]
    const bars = state.pattern.slice(0, state.bars).map((bar) => {
      const hits = [];
      const hands = [];
      for (let i=0;i<spb;i++){
        if (bar.hits[i]) {
          hits.push(i);
          hands.push(bar.hands[i] || "");
        }
      }
      return { hits, hands };
    });

    const timeSig = `${spb}/${spb}`;

    return {
      id: state.lessonId || "W1-L1",
      worldId: state.worldId || "W1",
      title: state.title || "Lesson",
      intro,
      ui: { ...state.ui },
      transport: {
        bpm: Number(state.bpm) || 90,
        bars: Number(state.bars) || 4,
        stepsPerBar: spb,
        timeSig
      },
      pattern: { bars }
    };
  }

  // State
  function makeDefaultState(){
    return normalizeState({
      lessonId: "W1-L1",
      worldId: "W1",
      title: "Klap mee in de maat",
      bpm: 90,
      bars: 4,
      stepsPerBar: 4,
      activeBar: 0,
      ui: {
        showMetronome: false,
        showBpm: false,
        showHits: false,
        showHands: false,
        showPlayStop: true
      },
      tutorial: ["", "", "", "", ""],
      pattern: []
    });
  }

  function normalizeState(s){
    let spb = clampInt(s.stepsPerBar ?? 4, 4, 16);
    if (![4,8,16].includes(spb)) spb = 4;

    const out = {
      lessonId: String(s.lessonId || "W1-L1"),
      worldId: String(s.worldId || "W1"),
      title: String(s.title || "Lesson"),
      bpm: clampInt(s.bpm ?? 90, 40, 220),
      bars: clampInt(s.bars ?? 4, 1, 64),
      stepsPerBar: spb,
      activeBar: clampInt(s.activeBar ?? 0, 0, 63),
      ui: {
        showMetronome: !!(s.ui && s.ui.showMetronome),
        showBpm: !!(s.ui && s.ui.showBpm),
        showHits: !!(s.ui && s.ui.showHits),
        showHands: !!(s.ui && s.ui.showHands),
        showPlayStop: s.ui ? !!s.ui.showPlayStop : true
      },
      tutorial: Array.isArray(s.tutorial) ? s.tutorial.slice(0,5) : ["","","","",""],
      pattern: Array.isArray(s.pattern) ? s.pattern : []
    };

    while (out.tutorial.length < 5) out.tutorial.push("");

    if (out.activeBar >= out.bars) out.activeBar = out.bars - 1;
    if (out.activeBar < 0) out.activeBar = 0;

    return out;
  }

  function remapPatternToSteps(nextSpb){
    // Best-effort: als je van 8->4 gaat, keep hits op 0,2,4,6 => map naar 0,1,2,3
    // als je van 4->8 gaat, dup naar 0,2,4,6
    // als je naar 16 gaat, map naar 0,4,8,12
    const prevSpb = state.stepsPerBar;

    const mapIndex = (i) => {
      // from prevSpb to nextSpb
      if (prevSpb === nextSpb) return i;

      // Normalize to quarter positions 0..3 then expand
      const toQuarterPos = () => {
        if (prevSpb === 4) return i;                         // 0..3
        if (prevSpb === 8) return Math.round(i / 2);         // 0..7 -> 0..3 approx
        return Math.round(i / 4);                            // 0..15 -> 0..3 approx
      };

      const q = clampInt(toQuarterPos(), 0, 3);

      if (nextSpb === 4) return q;
      if (nextSpb === 8) return q * 2;
      return q * 4;
    };

    const newPattern = [];
    for (let b=0; b<state.pattern.length; b++){
      const oldBar = state.pattern[b] || { hits: [], hands: [] };
      const nb = makeEmptyBar(nextSpb);

      for (let i=0; i<prevSpb; i++){
        if (oldBar.hits[i]) {
          const ni = mapIndex(i);
          nb.hits[ni] = true;
          const h = oldBar.hands[i] || "";
          nb.hands[ni] = (h === "R" || h === "L") ? h : "";
        }
      }
      newPattern.push(nb);
    }
    state.pattern = newPattern;
  }

  function ensurePatternSize(){
    while (state.pattern.length < state.bars) {
      state.pattern.push(makeEmptyBar(state.stepsPerBar));
    }
    if (state.pattern.length > state.bars) {
      state.pattern = state.pattern.slice(0, state.bars);
    }

    // Ensure each bar matches stepsPerBar length
    for (let b=0; b<state.pattern.length; b++){
      const bar = state.pattern[b];
      if (!bar || !Array.isArray(bar.hits) || !Array.isArray(bar.hands)) {
        state.pattern[b] = makeEmptyBar(state.stepsPerBar);
        continue;
      }
      if (bar.hits.length !== state.stepsPerBar || bar.hands.length !== state.stepsPerBar){
        // rebuild bar but keep overlapping indices
        const rebuilt = makeEmptyBar(state.stepsPerBar);
        const n = Math.min(bar.hits.length, rebuilt.hits.length);
        for (let i=0;i<n;i++){
          rebuilt.hits[i] = !!bar.hits[i];
          rebuilt.hands[i] = (bar.hands[i] === "R" || bar.hands[i] === "L") ? bar.hands[i] : "";
        }
        state.pattern[b] = rebuilt;
      }
    }

    if (state.activeBar >= state.bars) state.activeBar = state.bars - 1;
  }

  function makeEmptyBar(spb){
    return {
      hits: new Array(spb).fill(false),
      hands: new Array(spb).fill("")
    };
  }

  function setHit(barIndex, stepIndex, on){
    state.pattern[barIndex].hits[stepIndex] = !!on;
    if (!on) state.pattern[barIndex].hands[stepIndex] = "";
  }

  function setHand(barIndex, stepIndex, val){
    state.pattern[barIndex].hands[stepIndex] = val === "R" || val === "L" ? val : "";
  }

  function clearBar(barIndex){
    state.pattern[barIndex] = makeEmptyBar(state.stepsPerBar);
  }

  function autoHandsAlternate(barIndex){
    let next = "R";
    for (let i=0;i<state.stepsPerBar;i++){
      if (state.pattern[barIndex].hits[i]) {
        state.pattern[barIndex].hands[i] = next;
        next = next === "R" ? "L" : "R";
      } else {
        state.pattern[barIndex].hands[i] = "";
      }
    }
  }

  function hydrateFormFromState(){
    el.lessonId.value = state.lessonId;
    el.worldId.value = state.worldId;
    el.title.value = state.title;
    el.bpm.value = state.bpm;
    el.bars.value = state.bars;
    el.stepsPerBar.value = String(state.stepsPerBar);

    el.uiMetronome.checked = state.ui.showMetronome;
    el.uiBpm.checked = state.ui.showBpm;
    el.uiHits.checked = state.ui.showHits;
    el.uiHands.checked = state.ui.showHands;
    el.uiPlayStop.checked = state.ui.showPlayStop;

    el.t1.value = state.tutorial[0] || "";
    el.t2.value = state.tutorial[1] || "";
    el.t3.value = state.tutorial[2] || "";
    el.t4.value = state.tutorial[3] || "";
    el.t5.value = state.tutorial[4] || "";
  }

  function stateFromLessonConfig(cfg){
    const out = makeDefaultState();

    out.lessonId = String(cfg.id || "W1-L1");
    out.worldId = String(cfg.worldId || "W1");
    out.title = String(cfg.title || "Lesson");

    const spb = clampInt(cfg.transport?.stepsPerBar ?? 4, 4, 16);
    out.stepsPerBar = [4,8,16].includes(spb) ? spb : 4;

    out.bpm = clampInt(cfg.transport?.bpm ?? 90, 40, 220);
    out.bars = clampInt(cfg.transport?.bars ?? 4, 1, 64);

    out.ui = {
      showMetronome: !!cfg.ui?.showMetronome,
      showBpm: !!cfg.ui?.showBpm,
      showHits: !!cfg.ui?.showHits,
      showHands: !!cfg.ui?.showHands,
      showPlayStop: cfg.ui ? !!cfg.ui.showPlayStop : true
    };

    const introTexts = Array.isArray(cfg.intro) ? cfg.intro.map(x => x?.text || "") : [];
    out.tutorial = [introTexts[0]||"", introTexts[1]||"", introTexts[2]||"", introTexts[3]||"", introTexts[4]||""];

    out.pattern = [];
    for (let b=0; b<out.bars; b++){
      out.pattern.push(makeEmptyBar(out.stepsPerBar));
    }

    const bars = cfg.pattern?.bars || [];
    for (let b=0; b<Math.min(out.bars, bars.length); b++){
      const hits = Array.isArray(bars[b].hits) ? bars[b].hits : [];
      const hands = Array.isArray(bars[b].hands) ? bars[b].hands : [];
      hits.forEach((stepIndex, idx) => {
        if (stepIndex >=0 && stepIndex < out.stepsPerBar) {
          out.pattern[b].hits[stepIndex] = true;
          const h = hands[idx] || "";
          out.pattern[b].hands[stepIndex] = (h === "R" || h === "L") ? h : "";
        }
      });
    }

    out.activeBar = 0;
    return out;
  }

  function loadInitialState(){
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return makeDefaultState();
    try{
      const s = JSON.parse(raw);
      return normalizeState(s);
    }catch{
      return makeDefaultState();
    }
  }

  function byId(id){ return document.getElementById(id); }
  function clampInt(v, min, max){
    const n = Math.round(Number(v));
    if (!Number.isFinite(n)) return min;
    return Math.max(min, Math.min(max, n));
  }

  function toast(msg){
    console.log("[LessonEditor]", msg);
    alert(msg);
  }
</script>
</body>
</html>
