<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Medieval Drones ‚Äî Tape Loop Demo</title>
  <style>
    body { background: #fef8e8; color: #222; font-family: sans-serif; text-align:center; padding:2rem; }
    button { margin:0.5rem; padding:1rem 2rem; font-size:1rem; }
    input { width:80%; }
    #filename { margin-top:1rem; font-style: italic; }
    #log {
      margin-top:2rem; text-align:left; max-height:200px; overflow-y:auto;
      background:#fff; border:1px solid #ccc; padding:1rem;
      white-space: pre-wrap; font-size:0.9rem; line-height:1.2;
    }
  </style>
</head>
<body>
  <h1>Medieval Drones ‚Äî Tape Loop Demo</h1>
  <button id="load">Load Random Audio</button>
  <div id="filename">No audio loaded yet.</div>

  <div id="controls" style="display:none; margin-top:1rem;">
    <p>
      Start (s): <input type="number" id="start" min="0" step="0.1" value="0"/>
      Length (s): <input type="number" id="length" min="0.1" step="0.1" value="1"/>
    </p>
    <button id="playOnce">Play Slice</button>
    <label>
      <input type="checkbox" id="reverse"/> Reverse
    </label>
    <label>
      <input type="checkbox" id="loopToggle"/> Loop Slice
    </label>
  </div>

  <div id="tape" style="display:none; margin-top:1rem;">
    <p>
      Delay Time (s): <input type="range" id="delayTime" min="0" max="5" step="0.01" value="1.5"/>
      Feedback: <input type="range" id="feedback" min="0" max="0.95" step="0.01" value="0.6"/>
      Rate: <input type="range" id="playbackRate" min="0.1" max="3" step="0.01" value="1"/>
    </p>
    <button id="startLoop">Start Tape Loop</button>
    <button id="stopLoop">Stop Loop</button>
  </div>

  <div id="log">üìù Log:</div>

  <script>
    const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    let buffer, sliceBuffer, loopSource, delayNode, feedbackNode;

    function log(msg) {
      const L = document.getElementById('log');
      L.textContent += '\n' + msg;
      L.scrollTop = L.scrollHeight;
    }

    async function resumeIfNeeded() {
      if (audioCtx.state === 'suspended') {
        await audioCtx.resume();
        log('üîä AudioContext resumed');
      }
    }

    async function fetchRandomIdentifier() {
      log('üîç Searching Librivox audio‚Ä¶');
      const res = await fetch(
        'https://archive.org/advancedsearch.php' +
        `?q=${encodeURIComponent('collection:librivoxaudio')}` +
        '&fl[]=identifier&rows=50&output=json'
      );
      const docs = (await res.json()).response.docs;
      if (!docs.length) throw new Error('No items found');
      const id = docs[Math.floor(Math.random()*docs.length)].identifier;
      log(`üéØ Picked: ${id}`);
      return id;
    }

    async function pickAudioFile(id) {
      log(`üì• Fetching metadata for ${id}‚Ä¶`);
      const meta = await (await fetch(`https://archive.org/metadata/${id}`)).json();
      const names = (meta.files||[])
        .map(f=>f.name)
        .filter(n=>/\.(mp3|ogg)$/i.test(n));
      if (!names.length) throw new Error('No audio files in ' + id);
      const file = names[Math.floor(Math.random()*names.length)];
      log(`üé∂ Selected: ${file}`);
      return file;
    }

    async function loadAudio() {
      await resumeIfNeeded();
      document.getElementById('load').disabled = true;
      log('‚¨áÔ∏è Loading‚Ä¶');
      try {
        const id = await fetchRandomIdentifier();
        const file = await pickAudioFile(id);
        document.getElementById('filename').textContent = `Loaded: ${id}/${file}`;
        const url = `https://archive.org/download/${encodeURIComponent(id)}/${encodeURIComponent(file)}`;
        log(`‚¨áÔ∏è Downloading ${url}`);
        const data = await (await fetch(url)).arrayBuffer();
        log('üîÑ Decoding‚Ä¶');
        buffer = await audioCtx.decodeAudioData(data);
        log(`‚úÖ Decoded (${buffer.duration.toFixed(2)}s)`);
        document.getElementById('controls').style.display = 'block';
        document.getElementById('tape').style.display = 'block';
      } catch(err) {
        log(`‚ùå ${err.message}`);
      } finally {
        document.getElementById('load').disabled = false;
      }
    }

    function makeSliceBuffer() {
      const s0  = Math.floor(parseFloat(start.value) * buffer.sampleRate);
      const len = Math.floor(parseFloat(length.value) * buffer.sampleRate);
      sliceBuffer = audioCtx.createBuffer(buffer.numberOfChannels, len, buffer.sampleRate);
      for (let ch=0; ch<buffer.numberOfChannels; ch++){
        const data = sliceBuffer.getChannelData(ch);
        buffer.copyFromChannel(data, ch, s0);
        if (reverse.checked) data.reverse();
      }
    }

    async function playOnce() {
      await resumeIfNeeded();
      if (!buffer) return alert('Load audio first!');
      makeSliceBuffer();
      const src = audioCtx.createBufferSource();
      src.buffer = sliceBuffer;
      src.playbackRate.value = parseFloat(playbackRate.value);
      src.connect(audioCtx.destination);
      src.start();
      log('‚ñ∂Ô∏è Played slice once');
    }

    async function startLoop() {
      await resumeIfNeeded();
      if (!buffer) return alert('Load audio first!');
      if (loopSource) loopSource.stop();
      makeSliceBuffer();

      delayNode    = audioCtx.createDelay(10);
      feedbackNode = audioCtx.createGain();
      delayNode.delayTime.value = parseFloat(delayTime.value);
      feedbackNode.gain.value   = parseFloat(feedback.value);

      loopSource = audioCtx.createBufferSource();
      loopSource.buffer = sliceBuffer;
      loopSource.loop   = loopToggle.checked;
      if (loopSource.loop) {
        loopSource.loopStart = parseFloat(start.value);
        loopSource.loopEnd   = loopSource.loopStart + parseFloat(length.value);
      }
      loopSource.playbackRate.value = parseFloat(playbackRate.value);

      // direct hit
      loopSource.connect(audioCtx.destination);
      // tape loop feedback ‚Üí delay ‚Üí feedback ‚Üí destination
      loopSource.connect(delayNode);
      delayNode.connect(feedbackNode);
      feedbackNode.connect(delayNode);
      delayNode.connect(audioCtx.destination);

      loopSource.start();
      log(`üîÅ Tape loop started (delay ${delayNode.delayTime.value}s, fb ${feedbackNode.gain.value})`);
    }

    function stopLoop() {
      if (loopSource) {
        loopSource.stop();
        loopSource = null;
        log('‚èπÔ∏è Tape loop stopped');
      }
    }

    load.onclick      = loadAudio;
    playOnce.onclick  = playOnce;
    startLoop.onclick = startLoop;
    stopLoop.onclick  = stopLoop;
  </script>
</body>
</html>
