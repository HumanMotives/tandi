<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Random Gene</title>

  <!-- Web Audio Controls for round knobs -->
  <script src="https://cdn.jsdelivr.net/npm/web-audio-controls@latest"></script>

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 1rem;
      display: flex;
      justify-content: center;
      background: #fef8e8;
      color: #222;
      font-family: sans-serif;
    }
    #app {
      width: 100%;
      max-width: 600px;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    h1 { text-align: center; margin: 0; }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
    }
    .row > * { flex: 1 1 120px; }
    .row button { flex: 0 1 auto; }
    label { display: flex; flex-direction: column; font-size: 0.9rem; }
    input[type=number] {
      margin-top: 0.25rem;
      padding: 0.25rem;
      font-size: 1rem;
      width: 100%;
    }
    webaudio-knob {
      margin-top: 0.25rem;
      --knob-start-angle: -0.75turn;
      --knob-end-angle: 0.75turn;
    }
    #log {
      background: #fff;
      border: 1px solid #ccc;
      padding: 0.75rem;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre-wrap;
      font-size: 0.85rem;
      line-height: 1.2;
    }
    button {
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="app">
    <h1>Random Gene</h1>

    <div class="row">
      <button id="load">Load Random Audio</button>
      <div id="filename" style="font-style:italic;">No audio loaded yet.</div>
    </div>

    <div id="sliceControls" class="row" style="display:none;">
      <label>
        Start (s)
        <input type="number" id="start" min="0" step="0.01" value="0"/>
      </label>
      <label>
        Length (s)
        <input type="number" id="length" min="0.01" step="0.005" value="0.1"/>
      </label>
      <label style="flex:0 1 auto; align-self:flex-end">
        <input type="checkbox" id="reverse"/> Reverse
      </label>
      <label style="flex:0 1 auto; align-self:flex-end">
        <input type="checkbox" id="loopToggle"/> Loop Slice
      </label>
    </div>

    <div id="knobs1" class="row" style="display:none;">
      <label>
        Delay Time
        <webaudio-knob id="delayKnob" min="0" max="5" step="0.01" value="1.5" diameter="60"></webaudio-knob>
      </label>
      <label>
        Feedback
        <webaudio-knob id="fbKnob" min="0" max="0.95" step="0.01" value="0.6" diameter="60"></webaudio-knob>
      </label>
      <label>
        Rate
        <webaudio-knob id="rateKnob" min="0.1" max="3" step="0.01" value="1" diameter="60"></webaudio-knob>
      </label>
    </div>

    <div id="knobs2" class="row" style="display:none;">
      <label>
        Attack
        <webaudio-knob id="attackKnob" min="0" max="1" step="0.01" value="0.01" diameter="50"></webaudio-knob>
      </label>
      <label>
        Decay
        <webaudio-knob id="decayKnob" min="0" max="1" step="0.01" value="0.1" diameter="50"></webaudio-knob>
      </label>
      <label>
        Sustain
        <webaudio-knob id="sustainKnob" min="0" max="1" step="0.01" value="0.7" diameter="50"></webaudio-knob>
      </label>
      <label>
        Release
        <webaudio-knob id="releaseKnob" min="0" max="3" step="0.01" value="0.5" diameter="50"></webaudio-knob>
      </label>
    </div>

    <div id="knobs3" class="row" style="display:none;">
      <label>
        Filter Freq
        <webaudio-knob id="filterKnob" min="100" max="20000" step="1" value="20000" diameter="60"></webaudio-knob>
      </label>
      <label>
        Reverb Mix
        <webaudio-knob id="wetKnob" min="0" max="1" step="0.01" value="0.3" diameter="60"></webaudio-knob>
      </label>
      <button id="randomizeAll">Randomize All</button>
    </div>

    <div id="playControls" class="row" style="display:none;">
      <button id="playOnce">Play Slice</button>
      <button id="startLoop">Start Loop</button>
      <button id="stopLoop">Stop Loop</button>
    </div>

    <div id="log">üìù Log:</div>
  </div>

  <script>
    const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    let buffer = null, sliceBuffer = null, irBuffer = null;
    let loopSource = null, delayNode = null, feedbackNode = null;

    // element refs
    const loadBtn      = document.getElementById('load');
    const fnEl         = document.getElementById('filename');
    const startEl      = document.getElementById('start');
    const lengthEl     = document.getElementById('length');
    const reverseEl    = document.getElementById('reverse');
    const loopToggleEl = document.getElementById('loopToggle');
    const delayKnob    = document.getElementById('delayKnob');
    const fbKnob       = document.getElementById('fbKnob');
    const rateKnob     = document.getElementById('rateKnob');
    const attackKnob   = document.getElementById('attackKnob');
    const decayKnob    = document.getElementById('decayKnob');
    const sustainKnob  = document.getElementById('sustainKnob');
    const releaseKnob  = document.getElementById('releaseKnob');
    const filterKnob   = document.getElementById('filterKnob');
    const wetKnob      = document.getElementById('wetKnob');
    const randBtn      = document.getElementById('randomizeAll');
    const sliceCtrls   = document.getElementById('sliceControls');
    const knobs1       = document.getElementById('knobs1');
    const knobs2       = document.getElementById('knobs2');
    const knobs3       = document.getElementById('knobs3');
    const playCtrls    = document.getElementById('playControls');
    const logEl        = document.getElementById('log');

    function log(msg) {
      logEl.textContent += '\n' + msg;
      logEl.scrollTop = logEl.scrollHeight;
    }

    async function resumeIfNeeded() {
      if (audioCtx.state === 'suspended') {
        await audioCtx.resume();
        log('üîä AudioContext resumed');
      }
    }

    async function loadIR() {
      if (irBuffer) return;
      try {
        const resp = await fetch('https://mdn.github.io/voice-change-o-matic/audio/concert-crowd.ogg');
        const data = await resp.arrayBuffer();
        irBuffer = await audioCtx.decodeAudioData(data);
        log('üéß Impulse response loaded');
      } catch (e) {
        log('‚ùå Failed to load IR');
      }
    }

    async function fetchRandomIdentifier() {
      log('üîç Searching Librivox audio‚Ä¶');
      const res = await fetch(
        'https://archive.org/advancedsearch.php' +
        `?q=${encodeURIComponent('collection:librivoxaudio')}&fl[]=identifier&rows=50&output=json`
      );
      const json = await res.json();
      const docs = json.response?.docs || [];
      if (!docs.length) throw new Error('No items found');
      const id = docs[Math.floor(Math.random()*docs.length)].identifier;
      log(`üéØ Picked: ${id}`);
      return id;
    }

    async function pickAudioFile(id) {
      log(`üì• Fetching metadata for ${id}‚Ä¶`);
      const meta = await (await fetch(`https://archive.org/metadata/${id}`)).json();
      const names = (meta.files||[]).map(f=>f.name).filter(n=>/\.(mp3|ogg)$/i.test(n));
      if (!names.length) throw new Error('No audio files in ' + id);
      const file = names[Math.floor(Math.random()*names.length)];
      log(`üé∂ Selected: ${file}`);
      return file;
    }

    async function loadAudio() {
      await resumeIfNeeded();
      loadBtn.disabled = true;
      loadBtn.textContent = 'Loading‚Ä¶';
      try {
        await loadIR();
        const id = await fetchRandomIdentifier();
        const file = await pickAudioFile(id);
        fnEl.textContent = `Loaded: ${id}/${file}`;
        const url = `https://archive.org/download/${encodeURIComponent(id)}/${encodeURIComponent(file)}`;
        log(`‚¨áÔ∏è Downloading ${url}`);
        const data = await (await fetch(url)).arrayBuffer();
        log('üîÑ Decoding‚Ä¶');
        buffer = await audioCtx.decodeAudioData(data);
        log(`‚úÖ Decoded (${buffer.duration.toFixed(2)}s)`);
        sliceCtrls.style.display = 'flex';
        knobs1.style.display      = 'flex';
        knobs2.style.display      = 'flex';
        knobs3.style.display      = 'flex';
        playCtrls.style.display   = 'flex';
      } catch(err) {
        log(`‚ùå ${err.message}`);
        fnEl.textContent = 'Failed to load audio';
      } finally {
        loadBtn.textContent = 'Load Random Audio';
        loadBtn.disabled = false;
      }
    }

    function makeSliceBuffer() {
      const sr = buffer.sampleRate;
      const s0 = Math.floor(parseFloat(startEl.value) * sr);
      const len= Math.floor(parseFloat(lengthEl.value) * sr);
      sliceBuffer = audioCtx.createBuffer(buffer.numberOfChannels, len, sr);
      for (let ch=0; ch<buffer.numberOfChannels; ch++){
        const data = sliceBuffer.getChannelData(ch);
        buffer.copyFromChannel(data, ch, s0);
        if (reverseEl.checked) data.reverse();
      }
    }

    function applyEnvelope(gainNode, now) {
      const A = parseFloat(attackKnob.value),
            D = parseFloat(decayKnob.value),
            S = parseFloat(sustainKnob.value),
            R = parseFloat(releaseKnob.value),
            L = parseFloat(lengthEl.value);
      const g = gainNode.gain;
      g.cancelScheduledValues(now);
      g.setValueAtTime(0, now);
      g.linearRampToValueAtTime(1, now + A);
      g.linearRampToValueAtTime(S, now + A + D);
      g.setValueAtTime(S, now + L);
      g.linearRampToValueAtTime(0, now + L + R);
    }

    async function playOnce() {
      await resumeIfNeeded();
      if (!buffer) return alert('Load audio first!');
      makeSliceBuffer();

      const src = audioCtx.createBufferSource();
      src.buffer = sliceBuffer;
      src.playbackRate.value = parseFloat(rateKnob.value);

      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = parseFloat(filterKnob.value);

      const envGain = audioCtx.createGain();
      applyEnvelope(envGain, audioCtx.currentTime);

      const convolver = audioCtx.createConvolver();
      if (irBuffer) convolver.buffer = irBuffer;

      const dryGain = audioCtx.createGain();
      const wetGain = audioCtx.createGain();
      wetGain.gain.value = parseFloat(wetKnob.value);

      // graph: src‚Üífilter‚ÜíenvGain‚Üídry‚Üídest
      //                        ‚Üò convolver‚Üíwet‚Üídest
      src.connect(filter);
      filter.connect(envGain);
      envGain.connect(dryGain);
      dryGain.connect(audioCtx.destination);
      envGain.connect(convolver);
      convolver.connect(wetGain);
      wetGain.connect(audioCtx.destination);

      src.start();
      log('‚ñ∂Ô∏è Played slice once');
    }

    async function startLoop() {
      await resumeIfNeeded();
      if (!buffer) return alert('Load audio first!');
      if (loopSource) loopSource.stop();
      makeSliceBuffer();

      const delayTime = parseFloat(delayKnob.value),
            fb        = parseFloat(fbKnob.value),
            rate      = parseFloat(rateKnob.value);

      delayNode    = audioCtx.createDelay(10);
      feedbackNode = audioCtx.createGain();
      delayNode.delayTime.value = delayTime;
      feedbackNode.gain.value   = fb;

      loopSource = audioCtx.createBufferSource();
      loopSource.buffer = sliceBuffer;
      loopSource.loop   = loopToggleEl.checked;
      if (loopSource.loop) {
        const startT = parseFloat(startEl.value);
        loopSource.loopStart = startT;
        loopSource.loopEnd   = startT + parseFloat(lengthEl.value);
      }
      loopSource.playbackRate.value = rate;

      // direct dry
      loopSource.connect(audioCtx.destination);
      // tape feedback loop
      loopSource.connect(delayNode);
      delayNode.connect(feedbackNode);
      feedbackNode.connect(delayNode);
      delayNode.connect(audioCtx.destination);

      loopSource.start();
      log(`üîÅ Loop started (delay ${delayTime}s, fb ${fb})`);
    }

    function stopLoop() {
      if (loopSource) {
        loopSource.stop();
        loopSource = null;
        log('‚èπÔ∏è Loop stopped');
      }
    }

    randBtn.onclick   = () => {
      if (!buffer) return;
      // randomize inputs
      const maxStart = buffer.duration - parseFloat(lengthEl.value);
      startEl.value  = (Math.random() * Math.max(0, maxStart)).toFixed(2);
      lengthEl.value = (0.01 + Math.random() * Math.min(buffer.duration,1)).toFixed(3);
      reverseEl.checked    = Math.random() > 0.5;
      loopToggleEl.checked = Math.random() > 0.5;
      delayKnob.value = (Math.random()*5).toFixed(2);
      fbKnob.value    = (Math.random()*0.95).toFixed(2);
      rateKnob.value  = (0.1 + Math.random()*2.9).toFixed(2);
      attackKnob.value  = (Math.random()*1).toFixed(2);
      decayKnob.value   = (Math.random()*1).toFixed(2);
      sustainKnob.value = (Math.random()).toFixed(2);
      releaseKnob.value = (Math.random()*3).toFixed(2);
      filterKnob.value  = (100 + Math.random()*19900).toFixed(0);
      wetKnob.value     = Math.random().toFixed(2);
      log('üîÄ Randomized all');
    };

    loadBtn.onclick     = loadAudio;
    document.getElementById('playOnce').onclick  = playOnce;
    document.getElementById('startLoop').onclick = startLoop;
    document.getElementById('stopLoop').onclick  = stopLoop;
  </script>
</body>
</html>
