<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Medieval Drones ‚Äî Audio Fetch Debug</title>
  <style>
    body { background: #fef8e8; color: #222; font-family: sans-serif; text-align:center; padding:2rem; }
    button { margin:0.5rem; padding:1rem 2rem; font-size:1rem; }
    input { width:80%; }
    #filename { margin-top:1rem; font-style: italic; }
    #log {
      margin-top:2rem; text-align:left; max-height:200px; overflow-y:auto;
      background:#fff; border:1px solid #ccc; padding:1rem;
      white-space: pre-wrap; font-size:0.9rem; line-height:1.2;
    }
  </style>
</head>
<body>
  <h1>Medieval Drones ‚Äî Audio Fetch Debug</h1>
  <button id="load">Load Random PD Audio</button>
  <div id="filename">No audio loaded yet.</div>
  <div id="controls" style="display:none; margin-top:1rem;">
    <p>
      Start (s): <input type="number" id="start" min="0" step="0.1" value="0"/>
      Length (s): <input type="number" id="length" min="0.1" step="0.1" value="1"/>
    </p>
    <button id="play">Play Slice</button>
  </div>

  <div id="log">üìù Log:</div>

  <script>
    const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    let buffer = null;

    function log(msg) {
      const L = document.getElementById('log');
      L.textContent += '\n' + msg;
      L.scrollTop = L.scrollHeight;
    }

    // 1. Fetch a random Librivox identifier
    async function fetchRandomIdentifier() {
      log('üîç Searching Librivox audio‚Ä¶');
      const q = 'collection:librivoxaudio';  // public-domain spoken audio
      const res = await fetch(
        'https://archive.org/advancedsearch.php' +
        `?q=${encodeURIComponent(q)}` +
        '&fl[]=identifier' +
        '&rows=50' +
        '&output=json'
      );
      const json = await res.json();
      log('üì• Search response:\n' + JSON.stringify(json, null, 2));
      const docs = json.response && json.response.docs;
      if (!docs || docs.length === 0) {
        throw new Error('No identifiers found in Librivox collection');
      }
      const id = docs[Math.floor(Math.random()*docs.length)].identifier;
      log(`üéØ Picked identifier: ${id}`);
      return id;
    }

    // 2. Pick a random audio file (mp3/ogg) from that item
    async function pickAudioFile(id) {
      log(`üì• Fetching metadata for ${id}‚Ä¶`);
      const metaRes = await fetch(`https://archive.org/metadata/${id}`);
      const meta = await metaRes.json();
      const files = meta.files || [];
      log('üì• Files list (first 10):\n' + JSON.stringify(files.slice(0,10).map(f=>f.name), null, 2));
      const audioFiles = files
        .map(f => f.name)
        .filter(name => /\.(mp3|ogg)$/i.test(name));
      if (!audioFiles.length) {
        throw new Error('No audio files in ' + id);
      }
      const fileName = audioFiles[Math.floor(Math.random()*audioFiles.length)];
      log(`üé∂ Selected file: ${fileName}`);
      return fileName;
    }

    // 3. Download & decode into AudioBuffer
    async function loadAudio() {
      document.getElementById('load').disabled = true;
      document.getElementById('load').textContent = 'Loading‚Ä¶';
      try {
        const id = await fetchRandomIdentifier();
        const fileName = await pickAudioFile(id);
        const url = `https://archive.org/download/${encodeURIComponent(id)}/${encodeURIComponent(fileName)}`;
        log(`‚¨áÔ∏è Downloading ${url}`);
        const resp = await fetch(url);
        const data = await resp.arrayBuffer();
        log('üîÑ Decoding audio data‚Ä¶');
        buffer = await audioCtx.decodeAudioData(data);
        log(`‚úÖ Decoded! Duration: ${buffer.duration.toFixed(2)}s`);
        document.getElementById('filename').textContent = `Loaded: ${id}/${fileName}`;
        document.getElementById('controls').style.display = 'block';
      } catch (err) {
        console.error(err);
        log(`‚ùå Error: ${err.message}`);
        document.getElementById('filename').textContent = 'Failed to load audio';
      } finally {
        document.getElementById('load').textContent = 'Load Random PD Audio';
        document.getElementById('load').disabled = false;
      }
    }

    // 4. Slice & play
    function playSlice(startSec, durSec) {
      if (!buffer) return alert('Load audio first!');
      log(`‚ñ∂Ô∏è Playing slice: start=${startSec}s, length=${durSec}s`);
      const sr = buffer.sampleRate;
      const startSample = Math.floor(startSec * sr);
      const lenSamples  = Math.floor(durSec  * sr);
      const slice = audioCtx.createBuffer(buffer.numberOfChannels, lenSamples, sr);
      for (let ch=0; ch<buffer.numberOfChannels; ch++) {
        buffer.copyFromChannel(slice.getChannelData(ch), ch, startSample);
      }
      const src = audioCtx.createBufferSource();
      src.buffer = slice;
      src.connect(audioCtx.destination);
      src.start();
    }

    document.getElementById('load').onclick = loadAudio;
    document.getElementById('play').onclick = () => {
      const start  = parseFloat(document.getElementById('start').value)  || 0;
      const length = parseFloat(document.getElementById('length').value) || 1;
      playSlice(start, length);
    };
  </script>
</body>
</html>
