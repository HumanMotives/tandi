<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Random Gene</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 1rem;
      display: flex;
      justify-content: center;
      background: #fef8e8;
      color: #222;
      font-family: sans-serif;
    }
    #app {
      width: 100%;
      max-width: 600px;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    h1 { text-align: center; margin: 0; }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
    }
    .row > * { flex: 1 1 120px; }
    .row button { flex: 0 1 auto; }
    label { display: flex; flex-direction: column; font-size: 0.9rem; }
    input[type=number], input[type=range] {
      margin-top: 0.25rem;
      padding: 0.25rem;
      font-size: 1rem;
      width: 100%;
    }
    #log {
      background: #fff;
      border: 1px solid #ccc;
      padding: 0.75rem;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre-wrap;
      font-size: 0.85rem;
      line-height: 1.2;
    }
    button {
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="app">
    <h1>Random Gene</h1>

    <div class="row">
      <button id="load">Load Random Audio</button>
      <div id="filename" style="font-style:italic;">No audio loaded yet.</div>
    </div>

    <div id="sliceControls" class="row" style="display:none;">
      <label>
        Start (s)
        <input type="number" id="start" min="0" step="0.1" value="0"/>
      </label>
      <label>
        Length (s)
        <input type="number" id="length" min="0.1" step="0.1" value="1"/>
      </label>
      <label style="flex:0 1 auto; align-self:flex-end">
        <input type="checkbox" id="reverse"/> Reverse
      </label>
      <label style="flex:0 1 auto; align-self:flex-end">
        <input type="checkbox" id="loopToggle"/> Loop Slice
      </label>
    </div>

    <div id="tapeControls" class="row" style="display:none;">
      <label>
        Delay Time (s)
        <input type="range" id="delayTime" min="0" max="5" step="0.01" value="1.5"/>
      </label>
      <label>
        Feedback
        <input type="range" id="feedback" min="0" max="0.95" step="0.01" value="0.6"/>
      </label>
      <label>
        Rate
        <input type="range" id="playbackRate" min="0.1" max="3" step="0.01" value="1"/>
      </label>
    </div>

    <div id="playControls" class="row" style="display:none;">
      <button id="playOnce">Play Slice Once</button>
      <button id="startLoop">Start Tape Loop</button>
      <button id="stopLoop">Stop Loop</button>
    </div>

    <div id="log">üìù Log:</div>
  </div>

  <script>
    const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    let buffer = null, sliceBuffer = null;
    let loopSource = null, delayNode = null, feedbackNode = null;

    // element references
    const loadBtn      = document.getElementById('load');
    const fnEl         = document.getElementById('filename');
    const startEl      = document.getElementById('start');
    const lengthEl     = document.getElementById('length');
    const reverseEl    = document.getElementById('reverse');
    const loopToggleEl = document.getElementById('loopToggle');
    const delayTimeEl  = document.getElementById('delayTime');
    const feedbackEl   = document.getElementById('feedback');
    const rateEl       = document.getElementById('playbackRate');
    const sliceCtrls   = document.getElementById('sliceControls');
    const tapeCtrls    = document.getElementById('tapeControls');
    const playCtrls    = document.getElementById('playControls');
    const logEl        = document.getElementById('log');

    function log(msg) {
      logEl.textContent += '\n' + msg;
      logEl.scrollTop = logEl.scrollHeight;
    }

    async function resumeIfNeeded() {
      if (audioCtx.state === 'suspended') {
        await audioCtx.resume();
        log('üîä AudioContext resumed');
      }
    }

    async function fetchRandomIdentifier() {
      log('üîç Searching Librivox audio‚Ä¶');
      const q = 'collection:librivoxaudio';
      const res = await fetch(
        'https://archive.org/advancedsearch.php' +
        `?q=${encodeURIComponent(q)}&fl[]=identifier&rows=50&output=json`
      );
      const json = await res.json();
      const docs = json.response?.docs || [];
      if (!docs.length) throw new Error('No items found');
      const id = docs[Math.floor(Math.random()*docs.length)].identifier;
      log(`üéØ Picked: ${id}`);
      return id;
    }

    async function pickAudioFile(id) {
      log(`üì• Fetching metadata for ${id}‚Ä¶`);
      const meta = await (await fetch(`https://archive.org/metadata/${id}`)).json();
      const names = (meta.files||[])
        .map(f => f.name)
        .filter(n => /\.(mp3|ogg)$/i.test(n));
      if (!names.length) throw new Error('No audio files in ' + id);
      const file = names[Math.floor(Math.random()*names.length)];
      log(`üé∂ Selected: ${file}`);
      return file;
    }

    async function loadAudio() {
      await resumeIfNeeded();
      loadBtn.disabled = true;
      loadBtn.textContent = 'Loading‚Ä¶';
      try {
        const id = await fetchRandomIdentifier();
        const file = await pickAudioFile(id);
        fnEl.textContent = `Loaded: ${id}/${file}`;

        const url = `https://archive.org/download/${encodeURIComponent(id)}/${encodeURIComponent(file)}`;
        log(`‚¨áÔ∏è Downloading ${url}`);
        const data = await (await fetch(url)).arrayBuffer();
        log('üîÑ Decoding‚Ä¶');
        buffer = await audioCtx.decodeAudioData(data);
        log(`‚úÖ Decoded (${buffer.duration.toFixed(2)}s)`);

        sliceCtrls.style.display = 'flex';
        tapeCtrls.style.display  = 'flex';
        playCtrls.style.display  = 'flex';
      } catch(err) {
        log(`‚ùå ${err.message}`);
        fnEl.textContent = 'Failed to load audio';
      } finally {
        loadBtn.textContent = 'Load Random Audio';
        loadBtn.disabled = false;
      }
    }

    function makeSliceBuffer() {
      const sr = buffer.sampleRate;
      const s0 = Math.floor(parseFloat(startEl.value) * sr);
      const len= Math.floor(parseFloat(lengthEl.value) * sr);
      sliceBuffer = audioCtx.createBuffer(buffer.numberOfChannels, len, sr);
      for (let ch=0; ch<buffer.numberOfChannels; ch++){
        const data = sliceBuffer.getChannelData(ch);
        buffer.copyFromChannel(data, ch, s0);
        if (reverseEl.checked) data.reverse();
      }
    }

    async function playOnce() {
      await resumeIfNeeded();
      if (!buffer) return alert('Load audio first!');
      makeSliceBuffer();
      const src = audioCtx.createBufferSource();
      src.buffer = sliceBuffer;
      src.playbackRate.value = parseFloat(rateEl.value);
      src.connect(audioCtx.destination);
      src.start();
      log('‚ñ∂Ô∏è Played slice once');
    }

    async function startLoop() {
      await resumeIfNeeded();
      if (!buffer) return alert('Load audio first!');
      if (loopSource) loopSource.stop();
      makeSliceBuffer();

      // build delay+feedback
      delayNode    = audioCtx.createDelay(10);
      feedbackNode = audioCtx.createGain();
      delayNode.delayTime.value = parseFloat(delayTimeEl.value);
      feedbackNode.gain.value   = parseFloat(feedbackEl.value);

      loopSource = audioCtx.createBufferSource();
      loopSource.buffer = sliceBuffer;
      loopSource.loop   = loopToggleEl.checked;
      if (loopSource.loop) {
        const startT = parseFloat(startEl.value);
        loopSource.loopStart = startT;
        loopSource.loopEnd   = startT + parseFloat(lengthEl.value);
      }
      loopSource.playbackRate.value = parseFloat(rateEl.value);

      // direct dry
      loopSource.connect(audioCtx.destination);
      // tape feedback loop
      loopSource.connect(delayNode);
      delayNode.connect(feedbackNode);
      feedbackNode.connect(delayNode);
      delayNode.connect(audioCtx.destination);

      loopSource.start();
      log(`üîÅ Tape loop started (delay ${delayNode.delayTime.value}s, fb ${feedbackNode.gain.value})`);
    }

    function stopLoop() {
      if (loopSource) {
        loopSource.stop();
        loopSource = null;
        log('‚èπÔ∏è Tape loop stopped');
      }
    }

    loadBtn.onclick     = loadAudio;
    document.getElementById('playOnce').onclick  = playOnce;
    document.getElementById('startLoop').onclick = startLoop;
    document.getElementById('stopLoop').onclick  = stopLoop;
  </script>
</body>
</html>
