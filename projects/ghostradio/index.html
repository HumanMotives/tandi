<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Ghost Radio â€“ Simplified Start</title>
  <style>
    body {
      margin:0; padding:2rem 1rem;
      font-family:'IBM Plex Mono',monospace;
      background:#f5f1e6; color:#333;
      text-align:center;
    }
    h1 { font-size:2.5rem; margin-bottom:1rem; }
    #progressContainer {
      width:80%; max-width:300px; height:12px;
      background:#fdfbf8; border:1px solid #aaa;
      border-radius:6px; overflow:hidden;
      margin:1rem auto;
    }
    #progressBar { width:0; height:100%; background:#333; transition:width .2s; }
    #startBtn {
      margin:1rem; padding:.8rem 1.5rem;
      font-size:1rem; background:#333; color:#fdfbf8;
      border:none; border-radius:6px; cursor:pointer;
      display:none;
    }
    #startBtn:hover { background:#000; }
    #wave {
      display:none; width:100%; height:150px;
      background:rgba(0,0,0,0.05); margin:1.5rem 0;
    }
    #slider {
      display:none; width:80%; max-width:400px;
      margin:1rem auto;
    }
  </style>
</head>
<body>
  <h1>GHOST RADIO</h1>

  <!-- progress -->
  <div id="progressContainer"><div id="progressBar"></div></div>
  <button id="startBtn">Start Listening</button>

  <!-- once started -->
  <canvas id="wave"></canvas>
  <input type="range" id="slider" min="-1" max="1" step="0.01" value="0">

  <script>
  (async function(){
    // UI
    const progressBar = document.getElementById('progressBar');
    const startBtn    = document.getElementById('startBtn');
    const wave        = document.getElementById('wave');
    const slider      = document.getElementById('slider');

    // AudioContext & analyser
    const ctx = new (window.AudioContext||window.webkitAudioContext)();
    const analyser = ctx.createAnalyser();
    analyser.fftSize = 512;
    const bufLen = analyser.fftSize;
    const dataArr = new Uint8Array(bufLen);
    const masterGain = ctx.createGain();
    masterGain.gain.value = 1;
    analyser.connect(masterGain);
    masterGain.connect(ctx.destination);

    // preload buffers
    const files = ['sound1.mp3','sound2.mp3','sound3.mp3','sound4.mp3','sound5.mp3','sound6.mp3'];
    const base = location.pathname.replace(/[^\/]+$/, '');
    const buffers = {};
    for (let i=0; i<files.length; i++) {
      const f = files[i];
      const res = await fetch(base + 'sounds/' + f);
      const ab  = await res.arrayBuffer();
      buffers[f] = await ctx.decodeAudioData(ab);
      progressBar.style.width = `${((i+1)/files.length)*100}%`;
    }

    // show start button
    startBtn.style.display = 'inline-block';

    // layers
    let layers, mid = 1;
    function randFile(){ return files[Math.floor(Math.random()*files.length)]; }
    function playLayer(file){
      const src = ctx.createBufferSource();
      src.buffer = buffers[file]; src.loop = true;
      const g = ctx.createGain(); g.gain.value = 0;
      src.connect(g).connect(analyser);
      src.start();
      return {src, gain:g};
    }
    function initLayers(){
      if (layers) layers.forEach(l=>l.src.stop());
      layers = [playLayer(randFile()), playLayer(randFile()), playLayer(randFile())];
      layers.forEach((l,i)=>l.gain.setValueAtTime(i===mid?1:0,ctx.currentTime));
    }
    function shift(dir){
      if (dir<0) {
        layers[2].src.stop();
        layers = [ playLayer(randFile()), layers[0], layers[1] ];
      } else {
        layers[0].src.stop();
        layers = [ layers[1], layers[2], playLayer(randFile()) ];
      }
      layers.forEach((l,i)=>l.gain.setValueAtTime(i===mid?1:0,ctx.currentTime));
    }

    // crossfade via slider
    slider.addEventListener('input', ()=>{
      const x = parseFloat(slider.value);
      const raw = mid + x;
      if (raw<=0) { shift(-1); slider.value=0; return; }
      if (raw>=2) { shift(1); slider.value=0; return; }
      const li = Math.floor(raw), ri = Math.ceil(raw), f=raw-li;
      layers.forEach((l,i)=>{
        const t = i===li?1-f:(i===ri?f:0);
        l.gain.linearRampToValueAtTime(t,ctx.currentTime+0.05);
      });
    });

    // waveform draw
    const ctx2 = wave.getContext('2d');
    let last = 0;
    function draw(ts=0){
      requestAnimationFrame(draw);
      if (ts-last < 1000/30) return;
      last = ts;
      wave.width  = wave.clientWidth;
      analyser.getByteTimeDomainData(dataArr);
      ctx2.fillStyle='rgba(245,241,230,0.3)';
      ctx2.fillRect(0,0,wave.width,wave.height);
      ctx2.lineWidth=1; ctx2.strokeStyle='#555'; ctx2.beginPath();
      const slice = wave.width/bufLen; let x=0;
      for (let i=0;i<bufLen;i++){
        const v = dataArr[i]/128, y=v*wave.height/2;
        i===0?ctx2.moveTo(x,y):ctx2.lineTo(x,y);
        x+=slice;
      }
      ctx2.stroke();
    }

    // start on button
    startBtn.addEventListener('click', async ()=>{
      await ctx.resume();
      initLayers();
      startBtn.style.display='none';
      wave.style.display='block';
      slider.style.display='block';
      draw();
    });
  })();
  </script>
</body>
</html>
