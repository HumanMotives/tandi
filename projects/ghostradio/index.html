<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Ghost Radio – Carousel Layers</title>
  <style>
    body { margin:0; padding:1rem; font-family:'IBM Plex Mono',monospace; background:#f5f1e6; color:#333; }
    h1 { text-align:center; font-size:2rem; margin-bottom:1rem; }
    #loader { text-align:center; margin-bottom:1rem; }
    #statusText { margin-bottom:0.5rem; }
    #startButton {
      padding:0.8rem 1.5rem; font-size:1rem;
      background:#111; color:#f5f1e6; border:none; border-radius:6px;
      cursor:pointer;
    }
    #startButton:hover { background:#444; }
    .container { display:flex; flex-wrap:wrap; justify-content:center; gap:1rem; max-width:800px; margin:0 auto; }
    .panel { flex:1 1 280px; }
    #wave { width:100%; height:120px; background:rgba(0,0,0,0.05); display:none; }
    #knob {
      display:none; width:100px; height:100px; margin:0 auto 1.5rem;
      border:4px solid #888; border-radius:50%; background:#fdfbf8;
      touch-action:none; cursor:grab; position:relative; user-select:none;
    }
    #knob.active { cursor:grabbing; border-color:#000; }
    #knob::before {
      content:''; position:absolute; top:8px; left:50%;
      width:4px; height:30px; background:#333;
      transform-origin:bottom center;
    }
    .instructions { text-align:center; color:#666; display:none; }
    @media(max-width:600px){
      #wave{height:100px;} #knob{width:80px;height:80px;} #knob::before{height:24px;}
    }
  </style>
</head>
<body>
  <h1>GHOST RADIO</h1>
  <div id="loader" class="panel">
    <p id="statusText">Loading sounds…</p>
    <button id="startButton">Start Listening</button>
  </div>
  <div class="container">
    <div class="panel"><canvas id="wave"></canvas></div>
    <div class="panel">
      <div id="knob"></div>
      <p class="instructions">Rotate the dial to scan</p>
    </div>
  </div>

<script>
(async function(){
  const loader=document.getElementById('loader'),statusText=document.getElementById('statusText');
  const startButton=document.getElementById('startButton'),wave=document.getElementById('wave');
  const knob=document.getElementById('knob'),instr=document.querySelector('.instructions');

  const AudioCtx=window.AudioContext||window.webkitAudioContext; const ctx=new AudioCtx();
  const analyser=ctx.createAnalyser(); analyser.fftSize=256;
  const bufLen=analyser.fftSize, dataArr=new Uint8Array(bufLen);
  const masterGain=ctx.createGain(); masterGain.gain.value=1;
  analyser.connect(masterGain); masterGain.connect(ctx.destination);

  // Noise bed
  function makeNoiseBuffer(dur=2){
    const sz=ctx.sampleRate*dur, buf=ctx.createBuffer(1,sz,ctx.sampleRate), d=buf.getChannelData(0);
    for(let i=0;i<sz;i++) d[i]=Math.random()*2-1; return buf;
  }
  const noiseSrc=ctx.createBufferSource(); noiseSrc.buffer=makeNoiseBuffer(); noiseSrc.loop=true;
  const noiseGain=ctx.createGain(); noiseGain.gain.value=0.02;
  noiseSrc.connect(noiseGain).connect(analyser);

  // Sounds
  const files=['sound1.mp3','sound2.mp3','sound3.mp3','sound4.mp3','sound5.mp3','sound6.mp3'];
  const base=location.pathname.replace(/[^\\/]+$/,''); const buffers={};
  for(let i=0;i<files.length;i++){
    try{
      const res=await fetch(base+'sounds/'+files[i]); const ab=await res.arrayBuffer();
      buffers[files[i]]=await ctx.decodeAudioData(ab); statusText.textContent=`Loaded ${i+1}/${files.length}`;
    }catch(e){statusText.textContent='Error '+files[i]; return;}
  }
  statusText.textContent='Ready!';

  // Ring of layers
  const NUM=4; let ring=[];
  function createLayer(file,gainVal=0){
    const src=ctx.createBufferSource(); src.buffer=buffers[file]; src.loop=true;
    const dur=src.buffer.duration, start=Math.random()*Math.max(0,dur-12);
    src.loopStart=start; src.loopEnd=Math.min(dur,start+6+Math.random()*6);
    src.playbackRate.value=0.995+Math.random()*0.01;
    const g=ctx.createGain(); g.gain.value=gainVal; src.connect(g).connect(analyser); src.start();
    const phaseLFO={amp:0.003,freq:0.02+Math.random()*0.03,t:Math.random()*1000};
    const loopTimer={next:performance.now()+4000+Math.random()*4000};
    return {src,gain:g,file,phaseLFO,loopTimer};
  }
  function initRing(){
    ring.forEach(l=>{try{l.src.stop()}catch(_){}}); ring=[];
    const pick=[...files]; for(let i=0;i<NUM;i++){
      const f=pick.splice(Math.floor(Math.random()*pick.length),1)[0];
      ring.push(createLayer(f,i===0?1:0));
    }
  }

  // Dial
  let angle=0,lastAng=0,drag=false,cx=0,cy=0;
  let p=0,lastPIndex=0;
  knob.addEventListener('pointerdown',e=>{
    drag=true; knob.setPointerCapture(e.pointerId); knob.classList.add('active');
    const r=knob.getBoundingClientRect(); cx=r.left+r.width/2; cy=r.top+r.height/2;
    lastAng=Math.atan2(e.clientY-cy,e.clientX-cx)*180/Math.PI;
  });
  knob.addEventListener('pointermove',e=>{
    if(!drag) return;
    const ang=Math.atan2(e.clientY-cy,e.clientX-cx)*180/Math.PI;
    let d=ang-lastAng; if(d>180)d-=360;if(d<-180)d+=360; angle+=d; lastAng=ang;
    knob.style.transform=`rotate(${angle}deg)`;
  });
  ['pointerup','pointerleave'].forEach(ev=>knob.addEventListener(ev,e=>{
    drag=false; knob.classList.remove('active'); try{knob.releasePointerCapture(e.pointerId)}catch(_){}
  }));

  function updateAudio(dt){
    const raw=((angle%720)+720)%720;
    const val=raw<360? raw/360:(raw-720)/360; // [-1,1]
    p=(val+1)*(NUM/2);
    const spread=1.2; let maxMus=0;
    for(let i=0;i<NUM;i++){
      let d=Math.abs(i-p); d=Math.min(d,NUM-d);
      const w=Math.max(0,1-d/spread);
      ring[i].gain.gain.setTargetAtTime(w,ctx.currentTime,0.05);
      if(w>maxMus) maxMus=w;
    }
    noiseGain.gain.setTargetAtTime(0.02*(1-maxMus),ctx.currentTime,0.1);
  }
  function maybeSwap(){
    const idx=Math.round(p)%NUM; if(idx===lastPIndex) return;
    if(Math.abs(p-idx)<0.25) return;
    let far=(idx+Math.floor(NUM/2))%NUM;
    const old=ring[far]; const fresh=files[Math.floor(Math.random()*files.length)];
    const incoming=createLayer(fresh,0);
    old.gain.gain.setTargetAtTime(0,ctx.currentTime,0.15);
    incoming.gain.gain.setTargetAtTime(0.5,ctx.currentTime,0.15);
    setTimeout(()=>{try{old.src.stop()}catch(_){}} ,400);
    ring[far]=incoming; lastPIndex=idx;
  }
  function updatePhasing(dt){
    for(const l of ring){
      l.phaseLFO.t+=dt*l.phaseLFO.freq*0.001;
      const mod=1+l.phaseLFO.amp*Math.sin(2*Math.PI*l.phaseLFO.t);
      l.src.playbackRate.setTargetAtTime(mod,ctx.currentTime,0.2);
      const now=performance.now();
      if(now>l.loopTimer.next){
        const b=l.src.buffer, span=Math.min(12,b.duration);
        const c=Math.random()*Math.max(0,b.duration-span);
        l.src.loopStart=c+Math.random()*0.2-0.1;
        l.src.loopEnd=Math.min(b.duration,l.src.loopStart+span);
        l.loopTimer.next=now+4000+Math.random()*4000;
      }
    }
  }

  function drawWave(){
    const canvas=wave,c2=canvas.getContext('2d'); let last=0;
    function draw(ts=0){
      requestAnimationFrame(draw); if(ts-last<1000/30)return; last=ts;
      canvas.width=canvas.clientWidth;
      analyser.getByteTimeDomainData(dataArr);
      c2.fillStyle='rgba(245,241,230,0.3)'; c2.fillRect(0,0,canvas.width,canvas.height);
      c2.lineWidth=1; c2.strokeStyle='#555'; c2.beginPath();
      const slice=canvas.width/bufLen; let x=0;
      for(let i=0;i<bufLen;i++){ const v=dataArr[i]/128,y=v*canvas.height/2;
        i===0?c2.moveTo(x,y):c2.lineTo(x,y); x+=slice; }
      c2.stroke();
    }
    draw();
  }

  let lastTs=0;
  function tick(ts=0){
    requestAnimationFrame(tick);
    if(!lastTs) lastTs=ts; const dt=ts-lastTs; lastTs=ts;
    if(ring.length){ updateAudio(dt); maybeSwap(); updatePhasing(dt); }
  }

  startButton.addEventListener('click',async()=>{
    await ctx.resume(); try{noiseSrc.start()}catch(_){}
    loader.style.display='none'; initRing();
    wave.style.display='block'; knob.style.display='block'; instr.style.display='block';
    drawWave(); tick();
  });
})();
</script>
</body>
</html>
