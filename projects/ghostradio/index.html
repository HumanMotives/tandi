<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Ghost Radio — Category Blend (Textures / Tonal / Ritmic)</title>
<style>
  body{margin:0;padding:1rem;font-family:'IBM Plex Mono',monospace;background:#f5f1e6;color:#333}
  h1{margin:0 0 1rem;text-align:center;font-size:2rem}
  #loader{text-align:center;margin-bottom:1rem}
  #statusText{margin-bottom:.5rem}
  #startButton{padding:.8rem 1.5rem;font-size:1rem;background:#111;color:#f5f1e6;border:none;border-radius:6px;cursor:pointer}
  #startButton:hover{background:#444}

  .ui{max-width:900px;margin:0 auto;display:flex;flex-direction:column;gap:1rem}
  .row{display:flex;gap:.75rem;flex-wrap:wrap;align-items:center;justify-content:center}

  .control{background:#fdfbf8;border:1px solid #aaa;border-radius:10px;padding:.6rem .8rem;display:flex;align-items:center;gap:.6rem}
  .control label{font-size:.9rem}
  .control .auto{display:flex;align-items:center;gap:.35rem;background:#fff;border:1px solid #aaa;border-radius:8px;padding:.15rem .4rem;cursor:pointer}
  .control .auto input{accent-color:#111}
  input[type="range"]{width:160px}

  .switch{display:flex;gap:.5rem}
  .switch button{padding:.4rem .8rem;border:1px solid #aaa;border-radius:10px;background:#fdfbf8;cursor:pointer}
  .switch button.active{background:#111;color:#fdfbf8;border-color:#111}

  .canvases{position:relative;max-width:900px;margin:0 auto}
  #wave,#tuner{width:100%;height:160px;display:none}
  #tuner{position:absolute;left:0;top:0;pointer-events:none}
  #gesture{position:absolute;left:0;top:0;width:100%;height:160px;pointer-events:auto;touch-action:pan-x;background:transparent;display:none}

  .hint{font-size:.85rem;color:#666;text-align:center}

  #lockDisplay{ text-align:center; margin-top:.3rem; font-size:.9rem; color:#555; display:none; align-items:center; justify-content:center; gap:.5rem }
  #lockDisplay .led{display:inline-block;width:12px;height:12px;border-radius:50%;background:#444;transition:background .25s ease, box-shadow .25s ease}
  #lockDisplay .led.on{background:#1ed760; box-shadow:0 0 10px rgba(30,215,96,.75)}
  #stationName{font-weight:500}

  @media (max-width:600px){
    #wave,#tuner,#gesture{height:120px}
  }
</style>
</head>
<body>
  <h1>GHOST RADIO</h1>

  <div id="loader">
    <p id="statusText">Loading sounds…</p>
    <button id="startButton">Start Listening</button>
  </div>

  <div class="ui">
    <div class="row">
      <div class="control">
        <label for="focus">Focus</label>
        <input id="focus" type="range" min="0" max="1" step="0.001" value="0.5">
        <label class="auto"><input id="focusAuto" type="checkbox"> Auto</label>
      </div>
      <div class="control">
        <label for="age">Tape Age</label>
        <input id="age" type="range" min="0" max="1" step="0.001" value="0.25">
        <label class="auto"><input id="ageAuto" type="checkbox"> Auto</label>
      </div>
      <div class="control">
        <span>Mode</span>
        <div class="switch">
          <button id="amBtn">AM</button>
          <button id="fmBtn" class="active">FM</button>
        </div>
      </div>
    </div>

    <div class="canvases">
      <canvas id="wave"></canvas>
      <canvas id="tuner"></canvas>
      <div id="gesture" aria-label="Swipe to scan"></div>
    </div>
    <div id="lockDisplay" class="row">
      <span class="led" id="led"></span>
      <span id="stationName">— — —</span>
    </div>
    <div class="hint">Swipe anywhere on the ruler to scan</div>
  </div>

<script>
(async function(){
  // ===== UI refs =====
  const loader = document.getElementById('loader');
  const statusText = document.getElementById('statusText');
  const startButton = document.getElementById('startButton');
  const focusDial = document.getElementById('focus');
  const focusAuto = document.getElementById('focusAuto');
  const ageDial   = document.getElementById('age');
  const ageAuto   = document.getElementById('ageAuto');
  const amBtn     = document.getElementById('amBtn');
  const fmBtn     = document.getElementById('fmBtn');
  const wave      = document.getElementById('wave');
  const tuner     = document.getElementById('tuner');
  const gesture   = document.getElementById('gesture');
  const led       = document.getElementById('led');
  const lockDisplay = document.getElementById('lockDisplay');
  const stationNameEl = document.getElementById('stationName');

  // ===== Audio context & core nodes =====
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const ctx = new AudioCtx();

  const analyser = ctx.createAnalyser(); analyser.fftSize = 256;
  const bufLen = analyser.fftSize; const dataArr = new Uint8Array(bufLen);

  // master chain: (dry+reverb) -> masterFilter -> modeMakeup -> analyser -> destination
  const modeMakeup = ctx.createGain();
  const masterFilter = ctx.createBiquadFilter();
  masterFilter.type = 'lowpass';
  masterFilter.frequency.value = 12000;
  masterFilter.connect(modeMakeup);

  const masterGain = ctx.createGain(); masterGain.gain.value = 1;
  modeMakeup.connect(analyser).connect(masterGain).connect(ctx.destination);

  // Reverb: lightweight procedural IR (decaying noise)
  function makeIR(seconds=1.0, decay=2.0){
    const rate = ctx.sampleRate, len = Math.floor(rate * seconds);
    const ir = ctx.createBuffer(2, len, rate);
    for (let ch=0; ch<2; ch++){
      const data = ir.getChannelData(ch);
      for (let i=0;i<len;i++) data[i] = (Math.random()*2 - 1) * Math.pow(1 - i/len, decay);
    }
    return ir;
  }
  const convolver = ctx.createConvolver();
  convolver.buffer = makeIR(1.0, 2.0);

  const reverbGain = ctx.createGain(); reverbGain.gain.value = 0.18; // global wet
  convolver.connect(reverbGain).connect(masterFilter);

  // Noise (tape hiss) bed
  function makeNoiseBuffer(dur=2){
    const len = ctx.sampleRate * dur;
    const b = ctx.createBuffer(1, len, ctx.sampleRate);
    const d = b.getChannelData(0);
    for(let i=0;i<len;i++) d[i] = Math.random()*2-1;
    return b;
  }
  const noiseSrc = ctx.createBufferSource();
  noiseSrc.buffer = makeNoiseBuffer();
  noiseSrc.loop = true;
  const noiseGain = ctx.createGain(); noiseGain.gain.value = 0.015;
  noiseSrc.connect(noiseGain).connect(masterFilter);
  let noiseStarted = false;

  // ===== Categories & files (EDIT THESE LISTS TO MATCH YOUR REPO) =====
  const texturesFiles = [
    'texture01.mp3','texture02.mp3','texture03.mp3','texture04.mp3','texture05.mp3','texture06.mp3'
  ];
  const tonalFiles = [
    'pad01.mp3','pad02.mp3','pad03.mp3','pad04.mp3','pad05.mp3','pad06.mp3'
  ];
  const ritmicFiles = [
    'ritmic01.mp3','ritmic02.mp3','ritmic03.mp3','ritmic04.mp3','ritmic05.mp3','ritmic05.mp3'
  ];

  // Base path helper (auto-encode spaces in subfolders)
  const base = location.pathname.replace(/[^\/]+$/, '');
  function urlJoin(...parts){
    // join & encode each path segment except filenames that may include safe chars
    return parts.map((p,i)=>{
      // keep file names as-is; encode folder segments
      return (i < parts.length-1) ? encodeURIComponent(p) : p;
    }).join('/').replace(/%2F/g,'/');
  }

  // Preload buffers from categories
  const buffers = { Textures:{}, Tonal:{}, Ritmic:{} };
  async function loadCategory(folder, filesArr, bucket){
    for (let i=0;i<filesArr.length;i++){
      const f = filesArr[i];
      const url = base + urlJoin('sounds', folder, f);
      try{
        const res = await fetch(url);
        const ab  = await res.arrayBuffer();
        bucket[f] = await ctx.decodeAudioData(ab);
        statusText.textContent = `Loaded ${folder} ${i+1}/${filesArr.length}`;
      }catch(e){
        statusText.textContent = `Error loading ${folder}/${f}`;
        console.error(e);
        throw e;
      }
    }
  }

  try{
    await loadCategory('Textures',   texturesFiles, buffers.Textures);
    await loadCategory('Tonal Pads', tonalFiles,    buffers.Tonal);
    await loadCategory('Ritmic',     ritmicFiles,   buffers.Ritmic);
  }catch(e){
    // stop if any failed
    return;
  }
  statusText.textContent = 'Ready!';

  // ===== Trio of layers (Textures, Tonal, Ritmic) =====
  const CATS = ['Textures','Tonal','Ritmic']; // fixed order left→center→right idea-friendly
  const NUM = CATS.length;
  let ring = []; // { src,gain,panner,lp,send, file, cat, phaseLFO, loopTimer, spliceTimer }

  function pickFrom(bucket){ const keys = Object.keys(bucket); return keys[Math.floor(Math.random()*keys.length)]; }

  function createLayer(catName, gainVal=0){
    const bucket = buffers[catName];
    const file = pickFrom(bucket);
    const buf = bucket[file];

    const src = ctx.createBufferSource();
    src.buffer = buf;
    src.loop = true;

    // random loop window (3–15s)
    const D = buf.duration;
    const span = 3 + Math.random()*12;
    const start = Math.random() * Math.max(0, D - span);
    src.loopStart = start;
    src.loopEnd = Math.min(D, start + span);

    // base playback rate ±15%
    src.playbackRate.value = 0.85 + Math.random()*0.30;

    const g = ctx.createGain(); g.gain.value = gainVal;

    // per-layer LPF with tiny random Q
    const lp = ctx.createBiquadFilter();
    lp.type = 'lowpass'; lp.frequency.value = 12000; lp.Q.value = 0.0001 + Math.random()*0.5;

    // stereo panner + reverb send (post-panner)
    const panner = ctx.createStereoPanner(); panner.pan.value = 0;
    const send = ctx.createGain(); send.gain.value = 0.0;

    // routing
    src.connect(g);
    g.connect(lp).connect(panner);
    panner.connect(masterFilter);
    panner.connect(send).connect(convolver);

    src.start();

    const phaseLFO = {
      wowAmp: 0.003, wowHz: 0.25 + Math.random()*0.1,  t: Math.random()*100,
      fltAmp: 0.0015, fltHz: 6.5 + Math.random()*0.8
    };
    const loopTimer   = { next: performance.now() + 2500 + Math.random()*3500 };
    const spliceTimer = { next: performance.now() + 3000 + Math.random()*7000 };

    return { src, gain:g, panner, lp, send, file, cat:catName, phaseLFO, loopTimer, spliceTimer };
  }

  function initRing(){
    ring.forEach(l => { try { l.src.stop() } catch(_){ } });
    ring = [];
    // one per category
    for (let i=0;i<NUM;i++){
      const cat = CATS[i];
      ring.push(createLayer(cat, i===1 ? 1 : 0)); // start: make Tonal (index 1) a bit more centered
    }
  }

  // ===== Controls state =====
  let mode = 'FM';
  let focus = parseFloat(focusDial.value); // 0..1
  let age   = parseFloat(ageDial.value);   // 0..1
  let focusAutoOn = false, ageAutoOn = false;

  amBtn.onclick = () => { mode='AM'; amBtn.classList.add('active'); fmBtn.classList.remove('active'); };
  fmBtn.onclick = () => { mode='FM'; fmBtn.classList.add('active'); amBtn.classList.remove('active'); };
  focusDial.oninput = () => { if(!focusAutoOn) focus = parseFloat(focusDial.value); };
  ageDial.oninput   = () => { if(!ageAutoOn)   age   = parseFloat(ageDial.value);   };
  focusAuto.onchange= () => { focusAutoOn = focusAuto.checked; if (!focusAutoOn) focus = parseFloat(focusDial.value); };
  ageAuto.onchange  = () => { ageAutoOn   = ageAuto.checked;   if (!ageAutoOn)   age   = parseFloat(ageDial.value);   };

  // ===== Auto envelopes =====
  function makeAuto(startVal){
    return {
      cur: startVal, from: startVal, to: startVal,
      t: 0, dur: 1,
      next(){ this.from=this.cur; this.to=Math.random(); this.t=0; this.dur=3+Math.random()*8; },
      step(dt){ this.t+=dt; const k=Math.min(1,this.t/this.dur); const e=k*k*(3-2*k); this.cur=this.from+(this.to-this.from)*e; if(k>=1)this.next(); return this.cur; }
    };
  }
  const focusAutoEnv = makeAuto(focus); focusAutoEnv.next();
  const ageAutoEnv   = makeAuto(age);   ageAutoEnv.next();

  // ===== Swipe-to-scan with inertia =====
  let scrollX = 0;      // continuous position in ring units
  let p = 0;            // 0..NUM
  let dragging = false;
  let lastX = 0, lastT = 0;
  let velocity = 0;     // ring units per ms
  let inertial = false;

  const SENS = 1/90;     // px → ring units (tweak for speed)
  const FRICTION = 0.95; // inertia decay per frame
  const MAX_VEL = 0.02;  // clamp

  function onPointerDown(e){
    dragging = true; inertial = false; velocity = 0;
    gesture.setPointerCapture(e.pointerId);
    lastX = e.clientX; lastT = performance.now();
  }
  function onPointerMove(e){
    if (!dragging) return;
    const now = performance.now();
    const dx = e.clientX - lastX;
    const dt = Math.max(1, now - lastT);
    lastX = e.clientX; lastT = now;

    const delta = dx * SENS;
    scrollX += delta;

    const v = delta / dt;
    velocity = Math.max(-MAX_VEL, Math.min(MAX_VEL, v));
  }
  function onPointerUp(e){
    dragging = false;
    try{ gesture.releasePointerCapture(e.pointerId) }catch(_){}
    if (Math.abs(velocity) > 0.0002) inertial = true;
  }

  gesture.addEventListener('pointerdown', onPointerDown);
  gesture.addEventListener('pointermove', onPointerMove);
  ['pointerup','pointerleave','pointercancel'].forEach(ev=>gesture.addEventListener(ev, onPointerUp));

  // ===== LED lock + station names =====
  const stationNames = [
    "Echo Relay","Tape Horizon","Number Station 51","Phantom Loop","Crystal Dial",
    "Reich Drift","Signal Bloom","Midnight Carrier","Static Orchard","Orpheus Band",
    "Sferics 7","Dust & Splice","VLF Garden","Afterimage FM","Shortwave Arcade"
  ];
  let lockArmed = false, lockTimer = null, lastName = "";

  function setLED(on){ if(on){ led.classList.add('on'); lockDisplay.style.display='flex'; } else { led.classList.remove('on'); } }
  function pickName(){
    let n; do { n = stationNames[Math.floor(Math.random()*stationNames.length)]; } while (n===lastName);
    lastName = n; stationNameEl.textContent = n;
  }

  // ===== Crackle & Dropouts tied to Tape Age =====
  const noiseBufTiny = makeNoiseBuffer(0.05);
  function scheduleCrackle(){
    if (age <= 0.02) { setTimeout(scheduleCrackle, 1000); return; }
    const rate = age * 3;
    const nextIn = 200 + Math.random()*(1000/Math.max(0.25, rate));
    setTimeout(()=>{
      try{
        const pop = ctx.createBufferSource(); pop.buffer = noiseBufTiny;
        const hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 2500;
        const pg = ctx.createGain(); pg.gain.value = 0.0;
        pop.connect(hp).connect(pg).connect(masterFilter);
        const now = ctx.currentTime;
        pg.gain.setValueAtTime(0, now);
        pg.gain.linearRampToValueAtTime(0.05 + 0.12*age, now + 0.003);
        pg.gain.linearRampToValueAtTime(0, now + 0.006);
        pop.start(); pop.stop(now + 0.06);
      }catch(_){}
      scheduleCrackle();
    }, nextIn);
  }

  function scheduleDropouts(){
    if (age <= 0.05) { setTimeout(scheduleDropouts, 1500); return; }
    const every = 1500 + Math.random()*2500;
    setTimeout(()=>{
      const l = ring.length ? ring[Math.floor(Math.random()*ring.length)] : null;
      if (l){
        const now = ctx.currentTime;
        const dip = 0.5 + 0.5*age;
        const current = l.gain.gain.value || 1;
        l.gain.gain.setTargetAtTime(current * (1 - 0.3*dip), now, 0.01);
        l.gain.gain.setTargetAtTime(1.0, now + 0.06, 0.08);
      }
      scheduleDropouts();
    }, every);
  }

  // ===== Helpers =====
  function lerp(a,b,t){ return a + (b-a)*t; }
  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

  // ===== Audio update loop =====
  function updateAudio(dt){
    // Auto envelopes
    if (focusAuto.checked){
      focus = focusAutoEnv.step(dt/1000);
      focusDial.value = focus.toFixed(3);
    }
    if (ageAuto.checked){
      age = ageAutoEnv.step(dt/1000);
      ageDial.value = age.toFixed(3);
    }

    // inertia
    if (!dragging && inertial){
      scrollX += velocity * dt;
      velocity *= 0.95;
      if (Math.abs(velocity) < 0.00005) inertial = false;
    }

    // position in ring
    p = ((scrollX % NUM) + NUM) % NUM;

    // Focus mapping
    const spread   = lerp(0.8, 1.9, focus);     // slightly tighter base for 3 layers
    const panRange = lerp(0.25, 0.95, focus);
    const lpfFar   = lerp(6000, 2500, focus);
    const lpfNear  = lerp(14000, 9000, focus);
    const sendMax  = lerp(0.07, 0.42, focus);
    const sendMin  = lerp(0.0,  0.08, focus);

    // Tape Age mapping
    const ageDark  = lerp(1.0, 0.7, age);
    const noiseBase= 0.01 + 0.06*age;
    const wowMul   = 1.0 + 0.8*age;
    const fltMul   = 1.0 + 0.6*age;

    // Mode voicing + makeup
    if (mode==='AM'){
      masterFilter.type = 'bandpass';
      masterFilter.Q.setTargetAtTime(1.8 + 2.0*focus, ctx.currentTime, 0.1);
      masterFilter.frequency.setTargetAtTime(1400 + 1600*focus, ctx.currentTime, 0.1);
      modeMakeup.gain.setTargetAtTime(1.25, ctx.currentTime, 0.1);
    } else {
      masterFilter.type = 'lowpass';
      masterFilter.Q.setTargetAtTime(0.0001, ctx.currentTime, 0.1);
      masterFilter.frequency.setTargetAtTime(12000 + 3000*focus, ctx.currentTime, 0.1);
      modeMakeup.gain.setTargetAtTime(1.0, ctx.currentTime, 0.1);
    }

    // Per-layer processing
    let maxW = 0;
    for (let i=0;i<NUM;i++){
      const L = ring[i];
      // circular distance
      let d = Math.abs(i - p); d = Math.min(d, NUM - d);
      const w = clamp(1 - d/spread, 0, 1);
      if (w > maxW) maxW = w;

      // Gain
      L.gain.gain.setTargetAtTime(w, ctx.currentTime, 0.05);

      // Pan (non-linear)
      let delta = i - p;
      if (delta >  NUM/2) delta -= NUM;
      if (delta < -NUM/2) delta += NUM;
      const side = (delta >= 0) ? +1 : -1;
      const nonlin = Math.pow(1 - w, 0.65);
      L.panner.pan.setTargetAtTime(side * panRange * nonlin, ctx.currentTime, 0.06);

      // LPF + Age
      const nearCut = lpfNear * ageDark;
      const farCut  = lpfFar  * ageDark * (mode==='AM'?0.9:1.0);
      const cut = lerp(farCut, nearCut, w);
      L.lp.frequency.setTargetAtTime(cut, ctx.currentTime, 0.08);

      // Reverb send
      L.send.gain.setTargetAtTime(lerp(sendMax, sendMin, w), ctx.currentTime, 0.08);

      // Wow/Flutter
      const tSec = performance.now()/1000;
      const wow = L.phaseLFO.wowAmp * wowMul * Math.sin(2*Math.PI*L.phaseLFO.wowHz*tSec);
      const flt = L.phaseLFO.fltAmp * fltMul * Math.sin(2*Math.PI*L.phaseLFO.fltHz*tSec + i);
      const pr = 1.0 + wow + flt;
      L.src.playbackRate.setTargetAtTime(pr, ctx.currentTime, 0.2);

      // Loop nudge & micro-splice
      const nowMs = performance.now();
      if (nowMs > L.loopTimer.next){
        const b = L.src.buffer, span = Math.min(12, b.duration);
        const c = Math.random() * Math.max(0, b.duration - span);
        L.src.loopStart = c + (Math.random()*0.2 - 0.1);
        L.src.loopEnd   = Math.min(b.duration, L.src.loopStart + span);
        L.loopTimer.next = nowMs + 2500 + Math.random()*3500;
      }
      if (nowMs > L.spliceTimer.next){
        const jump = (Math.random()*0.1 + 0.05);
        const b = L.src.buffer;
        const newStart = Math.min(b.duration - 0.2, Math.max(0, L.src.loopStart + jump));
        const now = ctx.currentTime;
        const cur = L.gain.gain.value || 1;
        L.gain.gain.setTargetAtTime(cur*0.7, now, 0.01);
        L.src.loopStart = newStart;
        L.gain.gain.setTargetAtTime(w, now + 0.05, 0.05);
        L.spliceTimer.next = nowMs + 3000 + Math.random()*7000;
      }
    }

    // Noise ducks under loudest; AM slightly hissier
    noiseGain.gain.setTargetAtTime(noiseBase * (1 - maxW) * (mode==='AM'?1.3:1.0), ctx.currentTime, 0.1);

    // LED lock (centered strongly) for 500ms
    if (maxW >= 0.9){
      if (!lockArmed){
        lockArmed = true;
        if (lockTimer) clearTimeout(lockTimer);
        lockTimer = setTimeout(()=>{ setLED(true); pickName(); }, 500);
      }
    } else {
      lockArmed = false;
      if (lockTimer) { clearTimeout(lockTimer); lockTimer = null; }
      setLED(false);
    }
  }

  // Station swap: replace the **farthest** layer and keep its category
  let lastSwapIdx = -1;
  function maybeSwap(){
    // find farthest layer from p
    let farIdx = 0, farDist = -1;
    for (let i=0;i<NUM;i++){
      let d = Math.abs(i - p); d = Math.min(d, NUM - d);
      if (d > farDist) { farDist = d; farIdx = i; }
    }
    // Hysteresis: only swap when we cross a new "station area"
    const nearestIdx = Math.round(p) % NUM;
    if (nearestIdx === lastSwapIdx) return;
    lastSwapIdx = nearestIdx;

    const old = ring[farIdx];
    const cat = old.cat;
    const incoming = createLayer(cat, 0);
    old.gain.gain.setTargetAtTime(0, ctx.currentTime, 0.15);
    incoming.gain.gain.setTargetAtTime(0.5, ctx.currentTime, 0.15);
    setTimeout(()=>{ try{ old.src.stop() }catch(_){ } }, 400);
    ring[farIdx] = incoming;
  }

  // ===== Visualization =====
  function drawWave(){
    const c = wave, ctx2 = c.getContext('2d'); let last = 0;
    function loop(ts=0){
      requestAnimationFrame(loop);
      if (ts - last < 1000/30) return; last = ts;
      c.width = c.clientWidth; c.height = c.clientHeight;
      analyser.getByteTimeDomainData(dataArr);
      ctx2.fillStyle = 'rgba(245,241,230,0.3)'; ctx2.fillRect(0,0,c.width,c.height);
      ctx2.lineWidth = 1; ctx2.strokeStyle = '#555'; ctx2.beginPath();
      const slice = c.width / bufLen; let x = 0;
      for (let i=0;i<bufLen;i++){
        const v = dataArr[i]/128; const y = v * c.height/2;
        if (i===0) ctx2.moveTo(x,y); else ctx2.lineTo(x,y);
        x += slice;
      }
      ctx2.stroke();
    }
    loop();
  }

  function drawTuner(){
    const c = tuner, g = c.getContext('2d'); let last = 0;
    function loop(ts=0){
      requestAnimationFrame(loop);
      if (ts - last < 1000/30) return; last = ts;
      c.width = c.clientWidth; c.height = c.clientHeight;
      g.clearRect(0,0,c.width,c.height);

      // "between" brightness
      let nearest = Math.min(...[0,1,2].map(i => {
        let d = Math.abs(i - p); return Math.min(d, NUM - d);
      }));
      const between = Math.max(0, Math.min(1, nearest / 0.6));

      // mid gray ticks; every 5th taller (tape ruler)
      g.strokeStyle = `rgba(80,80,80,${0.35 + 0.35*between})`;
      g.lineWidth = 1;
      g.beginPath();
      const spacing = 18;
      const off = (p * spacing * 1.2) % spacing;
      let n = 0;
      for (let x = -off; x < c.width; x += spacing){
        const tall = (n % 5 === 0);
        const h = tall ? c.height : c.height * 0.5;
        const y0 = tall ? 0 : (c.height - h)/2;
        g.moveTo(x, y0); g.lineTo(x, y0 + h);
        n++;
      }
      g.stroke();

      // center needle (thicker)
      g.strokeStyle = '#000'; g.lineWidth = 2.4;
      g.beginPath(); g.moveTo(c.width/2, 0); g.lineTo(c.width/2, c.height); g.stroke();
    }
    loop();
  }

  // Master tick
  let lastTs = 0;
  function tick(ts=0){
    requestAnimationFrame(tick);
    if (!lastTs) lastTs = ts; const dt = ts - lastTs; lastTs = ts;
    if (ring.length) { updateAudio(dt); maybeSwap(); }
  }

  // ===== Start =====
  startButton.addEventListener('click', async ()=>{
    await ctx.resume();
    if (!noiseStarted) { try { noiseSrc.start() } catch(_){ } noiseStarted = true; }

    loader.style.display = 'none';
    wave.style.display = 'block'; tuner.style.display = 'block'; gesture.style.display = 'block';
    lockDisplay.style.display = 'flex';

    initRing(); drawWave(); drawTuner(); tick();

    scheduleCrackle(); scheduleDropouts();
  });
})();
</script>
</body>
</html>
