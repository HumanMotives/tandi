<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
<title>BAUHAUS — grid groove</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#E9E6DB;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  canvas{display:block;touch-action:none;position:relative;z-index:0}
  #overlay{
    position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;
    background:#E9E6DB;gap:18px;z-index:9999;opacity:1;transition:opacity .35s ease
  }
  #overlay.hidden{opacity:0;pointer-events:none}
  h1{margin:0;font-size:40px;letter-spacing:.04em}
  p{margin:0 24px;max-width:26ch;text-align:center;opacity:.75}
  button{
    font:600 16px/1.1 inherit;padding:12px 22px;border-radius:12px;border:0;background:#111;color:#fff
  }
  .hint{position:fixed;left:50%;bottom:10px;transform:translateX(-50%);font-size:12px;
        background:rgba(255,255,255,.78);padding:6px 8px;border-radius:8px}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.39/Tone.min.js"></script>
</head>
<body>
<div id="overlay">
  <svg width="72" height="36" viewBox="0 0 72 36" fill="none" stroke="#111" stroke-width="3" stroke-linecap="round">
    <path d="M2 18c8 0 8-12 16-12s8 12 16 12 8-12 16-12 8 12 16 12"/>
  </svg>
  <h1>BAUHAUS</h1>
  <p>Minimal shapes, minimal groove. Tap cells to place steps; drag vertically to change timbre (round → sine, sharp → square).</p>
  <button id="startBtn">Play</button>
</div>
<div class="hint">tap=toggle • drag in cell=hardness • L/R=tempo • U/D=size • wheel/rotate=palette</div>

<script>
/* -------------------- palettes -------------------- */
const PALETTES = [
  { bg:"#E9E6DB", ink:"#0E234B" },
  { bg:"#E9E6DB", ink:"#111111" },
  { bg:"#F1EFE6", ink:"#325A8C" },
  { bg:"#EFE7D7", ink:"#2D2A26" },
  { bg:"#EEEAE0", ink:"#3C6E71" },
];
let paletteIndex = 0;
document.body.style.background = PALETTES[paletteIndex].bg;

/* -------------------- grid / state -------------------- */
const ROWS = 4, COLS = 16;
let tile, startX, startY;
let grid = [];
let shapeScale = 0.9;
let dragGlobal = null;

function resetPattern(){
  grid = Array.from({length:ROWS}, (_,r)=>(
    Array.from({length:COLS},(_,c)=>{
      if (r===0) return {active: c%4===0, hard:0.35};
      if (r===1) return {active: c%8===4, hard:0.55};
      if (r===2) return {active: c%2===1, hard:0.6};
      if (r===3) return {active: (c%8===0)||c===10, hard:0.25};
    })
  ));
}
resetPattern();

/* -------------------- p5 layout -------------------- */
function setup(){
  createCanvas(windowWidth, windowHeight);
  calcLayout();
  noLoop();
  draw();
}
function windowResized(){ resizeCanvas(windowWidth, windowHeight); calcLayout(); redraw(); }
function calcLayout(){
  const tileX = width / COLS, tileY = height / ROWS;
  tile = Math.min(tileX, tileY);
  startX = (width  - tile*COLS)/2;
  startY = (height - tile*ROWS)/2;
}

/* -------------------- draw cells -------------------- */
function draw(){
  const pal = PALETTES[paletteIndex];
  background(pal.bg);

  noStroke();
  for (let r=0;r<ROWS;r++){
    for (let c=0;c<COLS;c++){
      const cell = grid[r][c];
      const x = startX + c*tile, y = startY + r*tile, s = tile;

      fill(color(pal.ink + '1A')); rect(x+0.5, y+0.5, s-1, s-1, 6);

      const scl = Math.max(0.5, Math.min(1.4, shapeScale));
      const inner = s*scl;
      const cx = x + s/2, cy = y + s/2;

      const hard = cell.hard ?? 0.5;
      const rad = (1-hard) * (inner/2);

      if (cell.active){ fill(PALETTES[paletteIndex].ink); noStroke(); }
      else { noFill(); stroke(PALETTES[paletteIndex].ink); strokeWeight(Math.max(1, s*0.05)); }

      push(); translate(cx, cy); rectMode(CENTER); ellipseMode(CENTER);
      switch (r){
        case 0: rect(0,0, inner, inner, rad); break;                 // Kick
        case 1: if (hard<0.5){ arc(0,0,inner,inner,Math.PI,0,PIE); }  // Snare
                else { rect(0,0, inner, inner*0.68, rad*0.6); } break;
        case 2: rect(0,0, inner, inner*0.33, inner*0.5); break;       // Hat
        case 3: rect(0,0, inner*0.85, inner*0.55, rad); break;        // Bass
      }
      pop();
    }
  }
}

/* -------------------- hit test & edit -------------------- */
function cellAt(px, py){
  const c = Math.floor((px - startX)/tile);
  const r = Math.floor((py - startY)/tile);
  if (r>=0 && r<ROWS && c>=0 && c<COLS) return {r,c};
  return null;
}

let editing = null, lastY = 0, lastX = 0, tapT = 0;
function pointerDown(x,y){
  const hit = cellAt(x,y);
  if (hit){ editing = hit; lastY = y; lastX = x; }
  else { editing = null; lastX = x; lastY = y; dragGlobal = Math.abs(x-width/2) > Math.abs(y-height/2) ? 'bpm' : 'size'; }
}
function pointerMove(x,y){
  if (editing){
    const dy = y - lastY;
    const cell = grid[editing.r][editing.c];
    cell.hard = Math.max(0, Math.min(1, (cell.hard ?? 0.5) - dy*0.004));
    lastY = y; redraw();
  }else if (dragGlobal==='bpm'){
    const dx = x - lastX; lastX = x;
    bpm = Math.max(60, Math.min(160, bpm + dx*0.2));
    Tone.Transport.bpm.rampTo(bpm, 0.05);
  }else if (dragGlobal==='size'){
    const dy = y - lastY; lastY = y;
    shapeScale = Math.max(0.5, Math.min(1.4, shapeScale - dy*0.003));
    const cutoff = map(shapeScale, 0.5, 1.4, 5200, 300);
    if (filterNode) filterNode.frequency.rampTo(cutoff, 0.1);
    redraw();
  }
}
function pointerUp(x,y){
  const now = millis();
  const hit = cellAt(x,y);
  if (hit && editing && dist(x,y,lastX,lastY)<6){
    grid[hit.r][hit.c].active = !grid[hit.r][hit.c].active;
    redraw();
  }
  if (now - tapT < 300){
    paletteIndex=(paletteIndex+1)%PALETTES.length;
    document.body.style.background=PALETTES[paletteIndex].bg; redraw();
  }
  tapT = now;
  editing = null; dragGlobal = null;
}

/* -------------------- input wire-up -------------------- */
function mousePressed(){ startFromGesture(); pointerDown(mouseX,mouseY); return false; }
function mouseDragged(){ pointerMove(mouseX,mouseY); return false; }
function mouseReleased(){ pointerUp(mouseX,mouseY); return false; }
function touchStarted(){ startFromGesture(); pointerDown(touches[0].x,touches[0].y); return false; }
function touchMoved(){ pointerMove(touches[0].x,touches[0].y); return false; }
function touchEnded(){ pointerUp((touches[0]||{}).x||lastX,(touches[0]||{}).y||lastY); return false; }
function mouseWheel(e){
  paletteIndex = (paletteIndex + (e.deltaY>0?1:-1) + PALETTES.length) % PALETTES.length;
  document.body.style.background = PALETTES[paletteIndex].bg; redraw();
  return false;
}

/* -------------------- audio -------------------- */
let started=false, step=0, bpm=120;
let filterNode, reverbNode, comp, limit;
let kick, snareNoise, snareTone, snareCF, hat, bassSoft, bassHard, bassX;
const bassScale = ['C2','D#2','F2','G2','A#1','C3','D#3','F3'];

async function maybeStartAudio(){
  if (started) return;
  const ctx = Tone.getContext().rawContext; if (ctx.state!=='running') await ctx.resume();

  Tone.Destination.volume.value = -6;
  comp  = new Tone.Compressor({threshold:-18, ratio:3, attack:0.01, release:0.2}).toDestination();
  limit = new Tone.Limiter(-6).connect(comp);

  filterNode = new Tone.Filter(1500,'lowpass');
  reverbNode = new Tone.Reverb({decay:3.2, wet:0.2}).connect(limit);
  filterNode.connect(reverbNode);

  kick = new Tone.MembraneSynth({ pitchDecay:0.03, octaves:6, envelope:{attack:0.001, decay:0.25, sustain:0, release:0.06} }).connect(filterNode);
  kick.volume.value = -6;

  snareNoise = new Tone.NoiseSynth({ noise:{type:'white'}, envelope:{attack:0.001, decay:0.15, sustain:0} }).connect(filterNode);
  snareCF = new Tone.Filter(3000,'bandpass').connect(filterNode);
  snareTone = new Tone.Synth({ oscillator:{type:'triangle'}, envelope:{attack:0.001, decay:0.08, sustain:0, release:0.03} }).connect(snareCF);

  hat = new Tone.NoiseSynth({ noise:{type:'white'}, envelope:{attack:0.001, decay:0.06, sustain:0} }).connect(filterNode);

  bassSoft = new Tone.MonoSynth({ oscillator:{type:'sine'},   filter:{type:'lowpass',Q:0}, envelope:{attack:0.01,decay:0.15,sustain:0.6,release:0.25} });
  bassHard = new Tone.MonoSynth({ oscillator:{type:'square'}, filter:{type:'lowpass',Q:0}, envelope:{attack:0.005,decay:0.12,sustain:0.55,release:0.22} });
  bassX = new Tone.CrossFade(0).connect(filterNode);
  bassSoft.connect(bassX.a); bassHard.connect(bassX.b);
  bassSoft.volume.value = -10; bassHard.volume.value = -12;

  Tone.Transport.bpm.value = bpm;
  Tone.Transport.scheduleRepeat((time)=>{
    const col = step % COLS;
    if (grid[0][col].active){
      const h = grid[0][col].hard;
      kick.pitchDecay = lerp(0.06,0.02,h);
      kick.triggerAttackRelease('C1','16n',time,1.0);
    }
    if (grid[1][col].active){
      const h = grid[1][col].hard;
      snareNoise.envelope.decay = lerp(0.22,0.08,h);
      snareCF.frequency.value   = lerp(1800,3500,h);
      snareNoise.triggerAttack(time,0.8);
      snareTone.triggerAttackRelease('D#3','16n',time,0.3);
    }
    if (grid[2][col].active){
      const h = grid[2][col].hard;
      hat.envelope.decay = lerp(0.03,0.18,h);
      filterNode.frequency.rampTo(map(shapeScale,0.5,1.4,5200,300),0.08);
      hat.triggerAttack(time, lerp(0.25,0.6,h));
    }
    if (grid[3][col].active){
      const h = grid[3][col].hard;
      bassX.fade.rampTo(h,0.01);
      const note = bassScale[(col*3)%bassScale.length];
      bassSoft.triggerAttackRelease(note,'8n',time,0.8);
      bassHard.triggerAttackRelease(note,'8n',time,0.8);
    }
    step++;
  }, '16n');

  const pad = new Tone.PolySynth(Tone.Synth, {
    oscillator:{type:'sine'}, envelope:{attack:0.4, decay:0.2, sustain:0.6, release:1.2}
  }).connect(filterNode);
  new Tone.Loop((t)=>{ pad.triggerAttackRelease(['C4','D#4','G4'],'1m',t,0.2); }, '1m').start(0);

  Tone.Transport.start();
  started = true;
}

/* ---------- overlay start: do audio inside the gesture, then hide ---------- */
function hideOverlay(){
  const o = document.getElementById('overlay');
  o.classList.add('hidden');
  setTimeout(()=>{ o.style.display='none'; }, 380);
}
async function startFromGesture(){
  // called on any press/touch
  if (!started) {
    // ensure we start the audio context synchronously with the gesture
    try { await Tone.start(); } catch(e){}
    await maybeStartAudio();
  }
}
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
function handleOverlayStart(ev){
  ev.preventDefault();
  (async()=>{ try{ await Tone.start(); }catch(e){} await maybeStartAudio(); hideOverlay(); })();
}
startBtn.addEventListener('click', handleOverlayStart, {passive:false});
overlay.addEventListener('touchstart', handleOverlayStart, {passive:false});
</script>
</body>
</html>
