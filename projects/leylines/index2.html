<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
<title>BAUHAUS — 8-step</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#E9E6DB;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  canvas{display:block;touch-action:none;position:relative;z-index:0}
  #overlay{
    position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;
    background:#E9E6DB;gap:18px;z-index:9999;opacity:1;transition:opacity .35s ease
  }
  #overlay.hidden{opacity:0;pointer-events:none}
  h1{margin:0;font-size:40px;letter-spacing:.04em}
  p{margin:0 24px;max-width:28ch;text-align:center;opacity:.75}
  button{font:600 16px/1.1 inherit;padding:12px 22px;border-radius:12px;border:0;background:#111;color:#fff}
  .hint{position:fixed;left:50%;bottom:10px;transform:translateX(-50%);font-size:12px;
        background:rgba(255,255,255,.78);padding:6px 8px;border-radius:8px}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.39/Tone.min.js"></script>
</head>
<body>
<div id="overlay">
  <svg width="72" height="36" viewBox="0 0 72 36" fill="none" stroke="#111" stroke-width="3" stroke-linecap="round">
    <path d="M2 18c8 0 8-12 16-12s8 12 16 12 8-12 16-12 8 12 16 12"/>
  </svg>
  <h1>BAUHAUS</h1>
  <p>8 big steps · Tap to toggle · Drag in a tile to soften/sharpen · Double-tap to change shape.</p>
  <button id="startBtn">Play</button>
</div>
<div class="hint">tap=toggle • drag in tile=soft/hard • double-tap=shape • L/R=tempo • U/D=size • wheel=palette</div>

<script>
/* ---------------- palettes ---------------- */
const PALETTES = [
  { bg:"#E9E6DB", ink:"#0E234B" },
  { bg:"#E9E6DB", ink:"#111111" },
  { bg:"#F1EFE6", ink:"#325A8C" },
  { bg:"#EFE7D7", ink:"#2D2A26" },
  { bg:"#EEEAE0", ink:"#3C6E71" },
];
let paletteIndex = 0;
document.body.style.background = PALETTES[paletteIndex].bg;

/* ---------------- grid config ---------------- */
const ROWS = 4, COLS = 2;         // 2 columns × 4 rows = 8 steps
const ORDER = Array.from({length:ROWS*COLS}, (_,i)=>({r:Math.floor(i/2), c:i%2})); // row-major
let tile, startX, startY, shapeScale = 1.1;

// per-cell state
const SHAPES = ['circle','squircle','half','bar','pill','triangle'];
let grid = [];
function resetPattern(){
  grid = Array.from({length:ROWS}, (_,r)=>(
    Array.from({length:COLS},(_,c)=>({
      active: (r===0 && c===0) || (r===2),
      hard: 0.45 + (r*0.1),
      shape: (r + c) % SHAPES.length,
      solid: r%2===0
    }))
  ));
}
resetPattern();

/* ---------------- p5 layout ---------------- */
function setup(){
  createCanvas(windowWidth, windowHeight);
  calcLayout();
  noLoop();
  draw();
}
function windowResized(){ resizeCanvas(windowWidth, windowHeight); calcLayout(); redraw(); }
function calcLayout(){
  const pad = min(width, height)*0.04;
  const wTile = (width - pad*2) / COLS;
  const hTile = (height - pad*2) / ROWS;
  tile = min(wTile, hTile);
  startX = (width  - tile*COLS)/2;
  startY = (height - tile*ROWS)/2;
}

/* ---------------- draw ---------------- */
function draw(){
  const pal = PALETTES[paletteIndex];
  background(pal.bg);

  noStroke();
  for (let r=0;r<ROWS;r++){
    for (let c=0;c<COLS;c++){
      const cell = grid[r][c];
      const x = startX + c*tile, y = startY + r*tile, s = tile;

      // subtle tile panel
      push();
      drawingContext.globalAlpha = 0.07;
      fill(pal.ink);
      rect(x+0.75, y+0.75, s-1.5, s-1.5, 14);
      pop();

      // shape
      const scl = constrain(shapeScale, 0.7, 1.35);
      const inner = s*scl;
      const cx = x + s/2, cy = y + s/2;

      const hard = constrain(cell.hard ?? 0.5, 0, 1);
      const radius = (1-hard) * (inner/2);           // roundness

      // styles
      const ink = pal.ink;
      if (cell.solid){ fill(ink); noStroke(); }
      else { noFill(); stroke(ink); strokeWeight(max(2, s*0.06)); }

      push(); translate(cx, cy); rectMode(CENTER); ellipseMode(CENTER);
      drawShape(SHAPES[cell.shape], inner, radius, hard, cell.solid);
      pop();

      // current step highlight (faint ring)
      if (started){
        const cur = ORDER[step % ORDER.length];
        if (cur.r===r && cur.c===c){
          noFill(); stroke(ink); strokeWeight(2);
          drawingContext.setLineDash([8,8]);
          rect(x+6, y+6, s-12, s-12, 16);
          drawingContext.setLineDash([]);
        }
      }
    }
  }
}

/* fixed: no more getStyle(); use the 'solid' flag */
function drawShape(kind, size, rad, hard, solid){
  switch(kind){
    case 'circle':
      ellipse(0,0,size,size);
      break;
    case 'squircle':
      rect(0,0,size,size, rad);
      break;
    case 'pill':
      rect(0,0,size, size*0.5, size*0.5);
      break;
    case 'bar':
      rect(0,0,size, size*0.28, rad*0.5);
      break;
    case 'half':
      if (solid) arc(0,0,size,size, Math.PI, 0, PIE);
      else       arc(0,0,size,size, Math.PI, 0);
      break;
    case 'triangle':
      const h = size*0.55;
      triangle(-h, h*0.6, h, h*0.6, 0, -h);
      break;
  }
}

/* ---------------- hit-testing & gestures ---------------- */
function cellAt(px, py){
  const c = floor((px - startX)/tile);
  const r = floor((py - startY)/tile);
  if (r>=0 && r<ROWS && c>=0 && c<COLS) return {r,c};
  return null;
}

let editing=null, lastY=0, lastX=0, tapT=0;
let dragGlobal=null;

function pointerDown(x,y){
  const hit = cellAt(x,y);
  if (hit){ editing = hit; lastY = y; lastX = x; }
  else { editing=null; lastX=x; lastY=y; dragGlobal = abs(x-width/2) > abs(y-height/2) ? 'bpm':'size'; }
}
function pointerMove(x,y){
  if (editing){
    const dy = y - lastY; lastY = y;
    const cell = grid[editing.r][editing.c];
    cell.hard = constrain((cell.hard ?? 0.5) - dy*0.004, 0, 1);
    redraw();
  } else if (dragGlobal==='bpm'){
    const dx = x - lastX; lastX = x;
    bpm = constrain(bpm + dx*0.25, 50, 180);
    Tone.Transport.bpm.rampTo(bpm, 0.05);
  } else if (dragGlobal==='size'){
    const dy = y - lastY; lastY = y;
    shapeScale = constrain(shapeScale - dy*0.003, 0.7, 1.35);
    const cutoff = map(shapeScale, 0.7, 1.35, 5200, 350);
    if (filterNode) filterNode.frequency.rampTo(cutoff, 0.1);
    redraw();
  }
}
function pointerUp(x,y){
  const now = millis();
  const hit = cellAt(x,y);
  if (hit && editing && dist(x,y,lastX,lastY)<6){
    const cell = grid[hit.r][hit.c];
    cell.active = !cell.active;
    redraw();
  }
  if (now - tapT < 300 && hit){
    const cell = grid[hit.r][hit.c];
    if (keyIsDown(SHIFT)) cell.solid = !cell.solid;
    else cell.shape = (cell.shape + 1) % SHAPES.length;
    redraw();
  }
  tapT = now;
  editing=null; dragGlobal=null;
}

/* pointer wiring */
function mousePressed(){ startFromGesture(); pointerDown(mouseX,mouseY); return false; }
function mouseDragged(){ pointerMove(mouseX,mouseY); return false; }
function mouseReleased(){ pointerUp(mouseX,mouseY); return false; }
function touchStarted(){ startFromGesture(); pointerDown(touches[0].x,touches[0].y); return false; }
function touchMoved(){ pointerMove(touches[0].x,touches[0].y); return false; }
function touchEnded(){ pointerUp((touches[0]||{}).x||lastX,(touches[0]||{}).y||lastY); return false; }
function mouseWheel(e){
  paletteIndex = (paletteIndex + (e.deltaY>0?1:-1) + PALETTES.length) % PALETTES.length;
  document.body.style.background = PALETTES[paletteIndex].bg; redraw();
  return false;
}

/* ---------------- audio ---------------- */
let started=false, step=0, bpm=112;
let filterNode, reverbNode, comp, limit;
let kick, snareNoise, snareTone, snareCF, hat, bassSoft, bassHard, bassX;

async function maybeStartAudio(){
  if (started) return;
  const ctx = Tone.getContext().rawContext; if (ctx.state!=='running') await ctx.resume();

  Tone.Destination.volume.value = -6;
  comp  = new Tone.Compressor({threshold:-18, ratio:3, attack:0.01, release:0.2}).toDestination();
  limit = new Tone.Limiter(-6).connect(comp);

  filterNode = new Tone.Filter(1500,'lowpass');
  reverbNode = new Tone.Reverb({decay:3.2, wet:0.2}).connect(limit);
  filterNode.connect(reverbNode);

  kick = new Tone.MembraneSynth({ pitchDecay:0.03, octaves:6, envelope:{attack:0.001, decay:0.25, sustain:0, release:0.06} }).connect(filterNode);
  kick.volume.value = -6;

  snareNoise = new Tone.NoiseSynth({ noise:{type:'white'}, envelope:{attack:0.001, decay:0.15, sustain:0} }).connect(filterNode);
  snareCF = new Tone.Filter(3000,'bandpass').connect(filterNode);
  snareTone = new Tone.Synth({ oscillator:{type:'triangle'}, envelope:{attack:0.001, decay:0.08, sustain:0, release:0.03} }).connect(snareCF);

  hat = new Tone.NoiseSynth({ noise:{type:'white'}, envelope:{attack:0.001, decay:0.06, sustain:0} }).connect(filterNode);

  bassSoft = new Tone.MonoSynth({ oscillator:{type:'sine'},   filter:{type:'lowpass',Q:0}, envelope:{attack:0.01,decay:0.15,sustain:0.6,release:0.25} });
  bassHard = new Tone.MonoSynth({ oscillator:{type:'square'}, filter:{type:'lowpass',Q:0}, envelope:{attack:0.005,decay:0.12,sustain:0.55,release:0.22} });
  bassX = new Tone.CrossFade(0).connect(filterNode);
  bassSoft.connect(bassX.a); bassHard.connect(bassX.b);
  bassSoft.volume.value = -10; bassHard.volume.value = -12;

  Tone.Transport.bpm.value = bpm;
  Tone.Transport.scheduleRepeat((time)=>{
    const cur = ORDER[step % ORDER.length];
    const r = cur.r, c = cur.c;
    const cell = grid[r][c];

    if (r===0 && cell.active){
      const h = cell.hard;
      kick.pitchDecay = lerp(0.06,0.02,h);
      kick.triggerAttackRelease('C1','16n',time,1.0);
    }
    if (r===1 && cell.active){
      const h = cell.hard;
      snareNoise.envelope.decay = lerp(0.22,0.08,h);
      snareCF.frequency.value   = lerp(1800,3500,h);
      snareNoise.triggerAttack(time,0.8);
      snareTone.triggerAttackRelease('D#3','16n',time,0.3);
    }
    if (r===2 && cell.active){
      const h = cell.hard;
      hat.envelope.decay = lerp(0.03,0.18,h);
      filterNode.frequency.rampTo(map(shapeScale, 0.7, 1.35, 5200, 350), 0.08);
      hat.triggerAttack(time, lerp(0.25,0.6,h));
    }
    if (r===3 && cell.active){
      const h = cell.hard;
      bassX.fade.rampTo(h,0.01);
      const notes = ['C2','G1','A#1','F2','G2','A#2','C2','F2'];
      const idx = (r*COLS+c) % notes.length;
      const note = notes[idx];
      bassSoft.triggerAttackRelease(note,'8n',time,0.85);
      bassHard.triggerAttackRelease(note,'8n',time,0.85);
    }

    step++;
    if (!isLooping()) loop(); setTimeout(()=>noLoop(), 10);
  }, '8n');

  Tone.Transport.start();
  started = true;
}

/* start from user gesture + overlay fade */
async function startFromGesture(){
  if (!started) {
    try{ await Tone.start(); }catch(e){}
    await maybeStartAudio();
  }
}
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
function hideOverlay(){ overlay.classList.add('hidden'); setTimeout(()=>{ overlay.style.display='none'; redraw(); }, 380); }
function handleOverlayStart(ev){ ev.preventDefault(); (async()=>{ try{await Tone.start();}catch(e){} await maybeStartAudio(); hideOverlay(); })(); }
startBtn.addEventListener('click', handleOverlayStart, {passive:false});
overlay.addEventListener('touchstart', handleOverlayStart, {passive:false});

/* ---------------- pointer glue ---------------- */
function mousePressed(){ startFromGesture(); pointerDown(mouseX,mouseY); return false; }
function mouseDragged(){ pointerMove(mouseX,mouseY); return false; }
function mouseReleased(){ pointerUp(mouseX,mouseY); return false; }
function touchStarted(){ startFromGesture(); pointerDown(touches[0].x,touches[0].y); return false; }
function touchMoved(){ pointerMove(touches[0].x,touches[0].y); return false; }
function touchEnded(){ pointerUp((touches[0]||{}).x||lastX,(touches[0]||{}).y||lastY); return false; }

/* state vars used above */
let started=false, step=0, bpm=112;
let filterNode, reverbNode, comp, limit;
let kick, snareNoise, snareTone, snareCF, hat, bassSoft, bassHard, bassX;

</script>
</body>
</html>
