<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
<title>Leyletters – Modular Bauhaus Tiles</title>
<style>
  html,body { margin:0; height:100%; overflow:hidden; background:#E9E6DB; }
  canvas { display:block; touch-action:none; }
  .hint {
    position:fixed; left:50%; bottom:12px; transform:translateX(-50%);
    font:12px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    color:#222; background:rgba(255,255,255,0.7);
    padding:6px 10px; border-radius:8px; pointer-events:none; user-select:none;
  }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
</head>
<body>
<div class="hint">swipe L/R = flow • swipe U/D = size • pinch = rounding • rotate / wheel = palette • double-tap = reseed</div>

<script>
/* ---------------------------------------------------------
   Leyletters — modular geometric tiles (Bauhaus inspo)
   --------------------------------------------------------- */

// palettes (bg, ink)
const PALETTES = [
  { bg:"#E9E6DB", ink:"#0E234B" },          // warm beige + deep navy
  { bg:"#E9E6DB", ink:"#111111" },          // beige + black
  { bg:"#F1EFE6", ink:"#325A8C" },          // light paper + bauhaus blue
  { bg:"#F3F1E8", ink:"#3C6E71" },          // sage blue-green
  { bg:"#EFE7D7", ink:"#2D2A26" },          // newsprint + coal
];

let paletteIndex = 0;

// grid state
let cols, rows, tile;
let tiles = [];  // array of tile objects {type, rot, flip, phase}
let seed = Math.floor(Math.random()*1e9);

// morph params
let flowSpeed = 0.35;     // 0..1 (affects wobble motion)
let wobbleAmp = 0.12;     // 0..0.3
let shapeScale = 0.78;    // 0.5..1.0 (amount of solid in each tile)
let roundness  = 0.55;    // 0..1 (0 = rect, 1 = capsule/circle)

// gestures
let dragging=false, lastX=0, lastY=0;
let touchStartData = [];

function setup(){
  createCanvas(windowWidth, windowHeight);
  randomSeed(seed);
  buildGrid();
}

function windowResized(){
  resizeCanvas(windowWidth, windowHeight);
  buildGrid();
}

function buildGrid(){
  // pick tile size that fits nicely
  const target = 120; // px
  cols = max(3, floor(width / target));
  tile = width / cols;
  rows = max(4, floor(height / tile));
  tile = min(tile, height/rows); // keep square cells

  // re-seed tiles
  tiles = [];
  randomSeed(seed);
  const types = 13; // # of primitive glyphs below
  for (let r=0; r<rows; r++){
    for (let c=0; c<cols; c++){
      tiles.push({
        type: floor(random(types)),
        rot:  floor(random(4)),
        flip: random()<0.5?1:-1,
        phase: random(TAU)
      });
    }
  }
}

function draw(){
  const pal = PALETTES[paletteIndex % PALETTES.length];
  background(pal.bg);
  noStroke();
  const t = millis()/1000;

  // shadows / ink
  fill(pal.ink);

  // layout padding for poster feel
  const margin = tile*0.08;
  const startX = (width  - cols*tile)/2;
  const startY = (height - rows*tile)/2;

  for (let r=0; r<rows; r++){
    for (let c=0; c<cols; c++){
      const i = r*cols + c;
      const obj = tiles[i];
      const x = startX + c*tile + margin;
      const y = startY + r*tile + margin;
      const s = tile - margin*2;

      push();
      translate(x+s/2, y+s/2);

      // subtle flowing offset per row/col (wavy posters)
      const flow = sin( (t* (0.2 + flowSpeed*1.8)) + r*0.5 + obj.phase ) * wobbleAmp * s;
      translate(flow, 0);

      rotate(obj.rot * HALF_PI);

      // draw primitive
      drawGlyph(obj.type, s, shapeScale, roundness);
      pop();
    }
  }
}

// ---------------------------------------------------------
// Primitive glyphs — built from circles, half/quarters,
// bars and rounded rects. Everything obeys scale & rounding.
// ---------------------------------------------------------
function drawGlyph(type, s, k, r){
  // k = shapeScale; r = roundness (0..1)
  const inset = (1 - k) * s * 0.5;
  const w = s - inset*2;
  const h = w;
  const rad = lerp(0, w*0.5, r);  // corner radius

  rectMode(CENTER); ellipseMode(CENTER);
  noStroke(); // solid ink shapes

  switch(type){
    case 0: // full circle
      ellipse(0,0,w,w); break;

    case 1: // half circle right
      arc(0,0,w,w,-HALF_PI,HALF_PI,PIE); break;

    case 2: // half circle left
      arc(0,0,w,w,HALF_PI,-HALF_PI,PIE); break;

    case 3: // half circle top
      arc(0,0,w,w,PI,0,PIE); break;

    case 4: // half circle bottom
      arc(0,0,w,w,0,PI,PIE); break;

    case 5: // quarter circle TL
      arc(-w/2,-h/2,w,w,0,HALF_PI,PIE); break;

    case 6: // quarter circle TR
      arc( w/2,-h/2,w,w,HALF_PI,PI,PIE); break;

    case 7: // quarter circle BL
      arc(-w/2, h/2,w,w,-HALF_PI,0,PIE); break;

    case 8: // quarter circle BR
      arc( w/2, h/2,w,w,PI,PI+HALF_PI,PIE); break;

    case 9: // vertical bar (rounded)
      rect(0,0, w*0.42, h, rad); break;

    case 10: // horizontal bar (rounded)
      rect(0,0, w, h*0.42, rad); break;

    case 11: // capsule horizontal
      rect(0,0, w, h*0.58, w*0.5); break;

    case 12: // capsule vertical
      rect(0,0, w*0.58, h, h*0.5); break;
  }

  // Optional thin strokes overlay to echo poster wire feel:
  stroke(0,20); noFill();
  const lw = max(1, s*0.004);
  strokeWeight(lw);
  rect(0,0,w,h, rad*0.6);
}

// ---------------------------------------------------------
// Gestures
// ---------------------------------------------------------
function touchStarted(){
  touchStartData = touches.map(t=>({x:t.x,y:t.y}));
  if (touches.length===1){ dragging=true; lastX=touches[0].x; lastY=touches[0].y; }
  return false;
}
function touchMoved(){
  if (touches.length===1 && dragging){
    const dx = touches[0].x - lastX;
    const dy = touches[0].y - lastY;
    // L/R: flow speed & amplitude
    flowSpeed = constrain(flowSpeed + dx/width, 0.0, 1.0);
    wobbleAmp = constrain( map(flowSpeed, 0,1, 0.04, 0.28), 0.02, 0.3 );
    // U/D: size (thickness)
    shapeScale = constrain(shapeScale - dy*0.003, 0.45, 1.0);

    lastX=touches[0].x; lastY=touches[0].y;
  }
  else if (touches.length===2 && touchStartData.length===2){
    const [a0,b0] = touchStartData;
    const [a1,b1] = touches;
    // pinch = rounding
    const d0 = dist(a0.x,a0.y,b0.x,b0.y);
    const d1 = dist(a1.x,a1.y,b1.x,b1.y);
    if (d0>0) {
      const ratio = d1/d0;
      roundness = constrain(roundness * ratio, 0.02, 0.98);
    }
    // rotate = palette cycle (small threshold)
    const ang0 = atan2(b0.y-a0.y, b0.x-a0.x);
    const ang1 = atan2(b1.y-a1.y, b1.x-a1.x);
    if (abs(ang1-ang0) > 0.25) {
      paletteIndex = (paletteIndex + (ang1>ang0?1:-1) + PALETTES.length) % PALETTES.length;
      // also update page bg to match
      document.body.style.background = PALETTES[paletteIndex].bg;
    }
    touchStartData = touches.map(t=>({x:t.x,y:t.y}));
  }
  return false;
}
function touchEnded(){
  dragging=false; touchStartData=[];
  // double-tap reseed
  if (touches.length===0){
    if (!touchEnded.last) touchEnded.last = {time:0};
    const now = millis();
    if (now - touchEnded.last.time < 300) { reseed(); }
    touchEnded.last.time = now;
  }
  return false;
}

// Desktop equivalents
function mousePressed(){ dragging=true; lastX=mouseX; lastY=mouseY; return false; }
function mouseDragged(){
  const dx = mouseX-lastX, dy = mouseY-lastY;
  flowSpeed = constrain(flowSpeed + dx/width, 0.0, 1.0);
  wobbleAmp = constrain( map(flowSpeed, 0,1, 0.04, 0.28), 0.02, 0.3 );
  shapeScale = constrain(shapeScale - dy*0.003, 0.45, 1.0);
  lastX=mouseX; lastY=mouseY; return false;
}
function mouseReleased(){ dragging=false; return false; }
function doubleClicked(){ reseed(); return false; }
function mouseWheel(e){
  // wheel = palette cycle (or fine rounding)
  if (e.shiftKey){
    roundness = constrain(roundness + (-e.deltaY)*0.0008, 0.02, 0.98);
  } else {
    paletteIndex = (paletteIndex + (e.deltaY>0?1:-1) + PALETTES.length) % PALETTES.length;
    document.body.style.background = PALETTES[paletteIndex].bg;
  }
  return false;
}

function reseed(){
  seed = Math.floor(Math.random()*1e9);
  buildGrid();
}
</script>
</body>
</html>
