<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Better Ambient Generative Sequencer – Multi-lane v1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Tone.js -->
  <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>

  <style>
    /* Minimal styling, just to stay readable */
    body {
      margin: 0;
      padding: 20px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
    }
    h1 {
      font-size: 18px;
      margin-bottom: 4px;
    }
    p {
      font-size: 13px;
      line-height: 1.4;
      color: #ccc;
    }
    .row {
      margin-top: 16px;
      padding: 12px;
      border: 1px solid #333;
      border-radius: 6px;
    }
    label {
      display: block;
      font-size: 12px;
      margin-top: 8px;
      margin-bottom: 4px;
    }
    input[type="range"] {
      width: 100%;
    }
    button {
      margin-right: 8px;
      margin-top: 8px;
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      border-radius: 4px;
      border: 1px solid #555;
      background: #222;
      color: #eee;
    }
    button:active {
      background: #333;
    }
    .small {
      font-size: 11px;
      color: #aaa;
    }
    .status {
      font-size: 12px;
      margin-top: 6px;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <h1>Better Ambient Generative Sequencer – Multi-lane prototype</h1>
  <p>
    Two lanes:<br>
    • <strong>Harmony</strong> lane (slow chords / root-ish drones)<br>
    • <strong>Melody</strong> lane (phrases with mixed long/short notes, rhythmic shapes)<br>
    Clocked to BPM, grid-based gaps. Evolution controls how much the motif branches.
  </p>

  <div class="row">
    <button id="startStopBtn">Start</button>
    <button id="reseedBtn">Reseed motif / scale</button>
    <p class="small">
      Start: begins Transport-clocked lanes (bars).<br>
      Reseed: new scale + new base melody motif and chord path.
    </p>
  </div>

  <div class="row">
    <label for="bpmSlider">
      BPM (clock for both lanes):
      <span id="bpmLabel">70</span>
    </label>
    <input type="range" id="bpmSlider" min="40" max="120" step="1" value="70">

    <label for="densitySlider">
      Density — how much happens inside each melody phrase:
      <span id="densityLabel">0.40</span>
    </label>
    <input type="range" id="densitySlider" min="0" max="1" step="0.01" value="0.4">

    <label for="spaceSlider">
      Space — grid-aligned gaps between melody phrases (0 = frequent · 1 = rare):
      <span id="spaceLabel">0.40</span>
    </label>
    <input type="range" id="spaceSlider" min="0" max="1" step="0.01" value="0.4">

    <label for="stabilitySlider">
      Stability — harmonic stability (0 = roaming · 1 = anchored):
      <span id="stabilityLabel">0.70</span>
    </label>
    <input type="range" id="stabilitySlider" min="0" max="1" step="0.01" value="0.7">

    <label for="evolutionSlider">
      Evolution — 0 = same motif, 1 = constantly branching:
      <span id="evolutionLabel">0.40</span>
    </label>
    <input type="range" id="evolutionSlider" min="0" max="1" step="0.01" value="0.4">

    <p class="small">
      Density: notes per phrase & how “frilly” the rhythm is.<br>
      Space: bars between phrases (always on the grid).<br>
      Stability: how strongly chords gravitate around a center.<br>
      Evolution: motif mutation strength and how often new motifs appear.
    </p>
  </div>

  <div class="row">
    <div class="status" id="statusText"></div>
  </div>

  <script>
    // ---------- SCALES / HARMONIC SETUP ----------

    const scaleDefs = [
      { name: "C Ionian",    rootMidi: 48, degrees: [0, 2, 4, 5, 7, 9, 11] },
      { name: "D Dorian",    rootMidi: 50, degrees: [0, 2, 3, 5, 7, 9, 10] },
      { name: "F Lydian",    rootMidi: 53, degrees: [0, 2, 4, 6, 7, 9, 11] },
      { name: "G Mixolydian",rootMidi: 55, degrees: [0, 2, 4, 5, 7, 9, 10] }
    ];

    function randomChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function randomRange(min, max) {
      return min + Math.random() * (max - min);
    }

    // ---------- STATE ----------

    const state = {
      isRunning: false,
      barCount: 0,
      currentScaleIndex: 0,
      currentChordRootIndex: 0,   // degree index within scale
      baseMotif: null,            // { rhythmBeats:[], intervals:[], baseDegreeIndex }
      lastChordDegree: 0
    };

    // ---------- AUDIO ENGINE ----------

    let limiter, reverb, delay, chordSynth, melodySynth;

    function initAudio() {
      if (chordSynth) return;

      limiter = new Tone.Limiter(-8).toDestination();

      reverb = new Tone.Reverb({
        decay: 8,
        wet: 0.35
      }).connect(limiter);

      delay = new Tone.FeedbackDelay({
        delayTime: "8n",
        feedback: 0.3,
        wet: 0.25
      }).connect(reverb);

      // Harmony lane: soft pad-ish triangle
      chordSynth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: "triangle" },
        envelope: {
          attack: 1.0,
          decay: 2.0,
          sustain: 0.6,
          release: 6.0
        }
      }).connect(reverb);
      chordSynth.volume.value = -14;

      // Melody lane: plucky marimba-like
      const melodyFilter = new Tone.Filter({
        type: "lowpass",
        frequency: 4500,
        Q: 0.5
      }).connect(delay);

      melodySynth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: "triangle" },
        envelope: {
          attack: 0.001,
          decay: 0.25,
          sustain: 0,
          release: 1.2
        }
      }).connect(melodyFilter);
      melodySynth.volume.value = -10;

      Tone.Transport.bpm.value = parseFloat(bpmSlider.value) || 70;
    }

    function getScale() {
      return scaleDefs[state.currentScaleIndex % scaleDefs.length];
    }

    function getSecondsPerBeat() {
      const bpm = parseFloat(bpmSlider.value) || 70;
      return 60 / bpm;
    }

    // ---------- HARMONY LANE (CHORDS / DRONE) ----------

    function chooseChordDegree(stability) {
      const scale = getScale();
      const len = scale.degrees.length;
      const current = state.currentChordRootIndex;
      const r = Math.random();

      if (Math.random() < stability) {
        if (r < 0.6) {
          return current; // stay
        } else if (r < 0.8) {
          return (current + 1) % len;
        } else {
          return (current + len - 1) % len;
        }
      } else {
        // roam: pick some other degree, biased toward mediant / submediant
        const candidates = [2, 4, 5, 1, 0, 6].map(i => i % len);
        const filtered = candidates.filter(d => d !== current);
        return randomChoice(filtered);
      }
    }

    function scheduleChordBar(time, barIndex) {
      const scale = getScale();
      const degrees = scale.degrees;
      const rootMidi = scale.rootMidi;
      const secsPerBeat = getSecondsPerBeat();

      // Only change chord every 2 bars for now
      const chordSpanBars = 2;
      if (barIndex % chordSpanBars === 0) {
        const stability = parseFloat(stabilitySlider.value);
        state.currentChordRootIndex = chooseChordDegree(stability);
        state.lastChordDegree = state.currentChordRootIndex;
      }

      const degIndex = state.currentChordRootIndex;
      const degOffsetsTriad = [0, 2, 4].map(d => (degIndex + d) % degrees.length);

      const chordNotes = [];
      // Root-ish / low octave
      chordNotes.push(rootMidi + degrees[degOffsetsTriad[0]] - 12);
      // Mid triad
      chordNotes.push(rootMidi + degrees[degOffsetsTriad[0]]);
      chordNotes.push(rootMidi + degrees[degOffsetsTriad[1]]);
      chordNotes.push(rootMidi + degrees[degOffsetsTriad[2]]);
      // Optional top color
      if (Math.random() < 0.6) {
        chordNotes.push(rootMidi + degrees[degOffsetsTriad[1]] + 12);
      }

      const durationBeats = chordSpanBars * 4; // 4/4
      const durationSeconds = durationBeats * secsPerBeat;

      const uniqueNotes = [...new Set(chordNotes)];
      uniqueNotes.forEach(midi => {
        const freq = Tone.Midi(midi).toFrequency();
        chordSynth.triggerAttackRelease(freq, durationSeconds, time, 0.4);
      });
    }

    // ---------- MELODY LANE (PHRASES) ----------

    // Rhythm patterns in beats (4/4) – mix of long/short / bursts
    const rhythmPatternsSparse = [
      [1, 3],                // hit then long hold
      [2, 2],                // two long tones
      [1.5, 0.5, 2],         // long-short-long
      [0.5, 0.5, 3],         // two pickups then sustain
    ];

    const rhythmPatternsMedium = [
      [0.5, 0.5, 1, 2],
      [1, 0.5, 0.5, 2],
      [0.25, 0.25, 0.5, 1, 2],
      [0.5, 1, 0.5, 2],
    ];

    const rhythmPatternsDense = [
      [0.25, 0.25, 0.5, 0.5, 1, 1.5],
      [0.125, 0.125, 0.25, 0.5, 0.5, 2.5],
      [0.5, 0.25, 0.25, 0.5, 0.5, 1, 1],
      [0.25, 0.25, 0.25, 0.25, 1, 2], // fast flurry then hold
    ];

    const contourTypes = ["up", "down", "arch", "zigzag"];

    function pickRhythmPattern(density) {
      if (density < 0.3) return randomChoice(rhythmPatternsSparse);
      if (density < 0.7) return randomChoice(rhythmPatternsMedium);
      return randomChoice(rhythmPatternsDense);
    }

    function buildContour(len, type) {
      // Returns an array of scale-degree offsets like [0, +1, +2, +1, 0]
      const steps = [];

      if (type === "up") {
        let pos = 0;
        for (let i = 0; i < len; i++) {
          steps.push(pos);
          if (i < len - 1) pos += randomChoice([1, 1, 2]); // more likely small up
        }
      } else if (type === "down") {
        let pos = 0;
        for (let i = 0; i < len; i++) {
          steps.push(pos);
          if (i < len - 1) pos += randomChoice([-1, -1, -2]); // more likely small down
        }
      } else if (type === "arch") {
        const mid = Math.floor(len / 2);
        let pos = 0;
        for (let i = 0; i < len; i++) {
          steps.push(pos);
          if (i < mid) pos += randomChoice([1, 1, 2]);
          else if (i < len - 1) pos += randomChoice([-1, -1, -2]);
        }
      } else { // zigzag
        let pos = 0;
        let dir = 1;
        for (let i = 0; i < len; i++) {
          steps.push(pos);
          if (i < len - 1) {
            pos += dir * randomChoice([1, 2]);
            dir *= -1;
          }
        }
      }

      // Normalize to start at 0
      const start = steps[0];
      return steps.map(s => s - start);
    }

    function createBaseMotif(density) {
      const scale = getScale();
      const degrees = scale.degrees;
      const rootIndex = state.currentChordRootIndex;

      const rhythmBeats = pickRhythmPattern(density);
      const contourType = randomChoice(contourTypes);
      const contour = buildContour(rhythmBeats.length, contourType);

      // anchor motif base roughly around current chord degree, but not always root
      const chordDegrees = [0, 2, 4].map(d => (rootIndex + d) % degrees.length);
      const baseDegreeIndex = randomChoice(chordDegrees);

      return {
        rhythmBeats,
        contour,
        baseDegreeIndex
      };
    }

    function mutateMotif(baseMotif, evolution) {
      if (evolution <= 0.001) {
        return JSON.parse(JSON.stringify(baseMotif));
      }

      const clone = JSON.parse(JSON.stringify(baseMotif));

      // Small chance to tweak rhythm pattern
      if (Math.random() < evolution * 0.4) {
        const density = parseFloat(densitySlider.value);
        clone.rhythmBeats = pickRhythmPattern(density);
      }

      // Tweak contour
      clone.contour = clone.contour.map(step => {
        if (Math.random() < evolution * 0.6) {
          return step + randomChoice([-1, 0, 1]);
        }
        return step;
      });

      // Chance to transpose motif base degree
      if (Math.random() < evolution * 0.5) {
        const shift = randomChoice([-2, -1, 1, 2]);
        const scale = getScale();
        const len = scale.degrees.length;
        clone.baseDegreeIndex =
          (clone.baseDegreeIndex + shift + len) % len;
      }

      return clone;
    }

    function shouldPlayMelodyThisBar() {
      const space = parseFloat(spaceSlider.value);
      // Map space -> probability of phrase this bar
      // space=0 => ~0.9, space=1 => ~0.1
      const p = 0.9 - 0.8 * space;
      return Math.random() < p;
    }

    function scheduleMelodyBar(time, barIndex) {
      if (!shouldPlayMelodyThisBar()) return;

      const density = parseFloat(densitySlider.value);
      const evolution = parseFloat(evolutionSlider.value);
      const scale = getScale();
      const degrees = scale.degrees;
      const rootMidi = scale.rootMidi;
      const secsPerBeat = getSecondsPerBeat();

      if (!state.baseMotif) {
        state.baseMotif = createBaseMotif(density);
      }

      let motif = mutateMotif(state.baseMotif, evolution);

      // At high evolution, occasionally adopt mutated motif as new base
      if (evolution > 0.7 && Math.random() < (evolution - 0.7) * 1.5) {
        state.baseMotif = motif;
      }

      const { rhythmBeats, contour, baseDegreeIndex } = motif;

      let currentBeatOffset = 0;
      for (let i = 0; i < rhythmBeats.length; i++) {
        const durBeats = rhythmBeats[i];
        const offsetBeats = currentBeatOffset;

        const degreeIndex =
          (baseDegreeIndex + contour[i] + degrees.length) % degrees.length;
        const degreeOffset = degrees[degreeIndex];

        // Register selection: mostly around mid, occasionally high or low
        let octaveOffset;
        if (density < 0.5) {
          octaveOffset = randomChoice([0, 12]);
        } else {
          octaveOffset = randomChoice([0, 12, 24, -12]);
        }

        const midi = rootMidi + degreeOffset + octaveOffset;
        const freq = Tone.Midi(midi).toFrequency();

        // Duration in seconds, with slight variation
        const durSeconds = Math.max(
          0.1,
          durBeats * secsPerBeat * randomRange(0.9, 1.4)
        );

        const vel = randomRange(0.3, 0.7);

        melodySynth.triggerAttackRelease(
          freq,
          durSeconds,
          time + offsetBeats * secsPerBeat,
          vel
        );

        currentBeatOffset += durBeats;
      }
    }

    // ---------- FORM / TRANSPORT ----------

    function describeSection(barCount) {
      const idx = Math.floor(barCount / 4) % 3; // rough segments
      if (idx === 0) return "A";
      if (idx === 1) return "B";
      return "A'";
    }

    function updateStatus() {
      const scale = getScale();
      const secsPerBeat = getSecondsPerBeat();
      const info = [
        `Scale: ${scale.name}`,
        `Bar: ${state.barCount}`,
        `Section (rough): ${describeSection(state.barCount)}`,
        `Chord degree index: ${state.currentChordRootIndex}`,
        `BPM: ${parseFloat(bpmSlider.value).toFixed(0)}`,
        `Density: ${parseFloat(densitySlider.value).toFixed(2)} · Space: ${parseFloat(spaceSlider.value).toFixed(2)}`,
        `Stability: ${parseFloat(stabilitySlider.value).toFixed(2)} · Evolution: ${parseFloat(evolutionSlider.value).toFixed(2)}`,
        `Seconds per beat: ${secsPerBeat.toFixed(3)}`
      ];
      statusText.textContent = info.join("\n");
    }

    function onBar(time) {
      if (!state.isRunning) return;

      // Harmony lane: pad chords
      scheduleChordBar(time, state.barCount);

      // Melody lane: phrase or rest
      scheduleMelodyBar(time, state.barCount);

      state.barCount += 1;
      updateStatus();
    }

    // ---------- START / STOP / RESEED ----------

    async function startEngine() {
      if (state.isRunning) return;
      initAudio();
      await Tone.start();

      state.isRunning = true;
      state.barCount = 0;
      state.baseMotif = null;

      // random starting scale and chord degree
      state.currentScaleIndex = Math.floor(Math.random() * scaleDefs.length);
      state.currentChordRootIndex = Math.floor(Math.random() * getScale().degrees.length);

      Tone.Transport.cancel(); // clear previous events if any
      Tone.Transport.bpm.value = parseFloat(bpmSlider.value) || 70;

      Tone.Transport.scheduleRepeat(onBar, "1m");
      Tone.Transport.start("+0.05");
      updateStatus();
    }

    function stopEngine() {
      state.isRunning = false;
      Tone.Transport.stop();
      Tone.Transport.cancel();
      statusText.textContent = "Stopped.";
    }

    function reseed() {
      // New scale + new motif
      state.currentScaleIndex = Math.floor(Math.random() * scaleDefs.length);
      state.baseMotif = null;
      state.barCount = 0;
      statusText.textContent += "\nReseed: new scale + motif.";
    }

    // ---------- UI BINDINGS ----------

    const startStopBtn = document.getElementById("startStopBtn");
    const reseedBtn = document.getElementById("reseedBtn");
    const bpmSlider = document.getElementById("bpmSlider");
    const densitySlider = document.getElementById("densitySlider");
    const spaceSlider = document.getElementById("spaceSlider");
    const stabilitySlider = document.getElementById("stabilitySlider");
    const evolutionSlider = document.getElementById("evolutionSlider");

    const bpmLabel = document.getElementById("bpmLabel");
    const densityLabel = document.getElementById("densityLabel");
    const spaceLabel = document.getElementById("spaceLabel");
    const stabilityLabel = document.getElementById("stabilityLabel");
    const evolutionLabel = document.getElementById("evolutionLabel");
    const statusText = document.getElementById("statusText");

    startStopBtn.addEventListener("click", () => {
      if (!state.isRunning) {
        startEngine().catch(console.error);
        startStopBtn.textContent = "Stop";
      } else {
        stopEngine();
        startStopBtn.textContent = "Start";
      }
    });

    reseedBtn.addEventListener("click", () => {
      reseed();
    });

    function updateLabels() {
      bpmLabel.textContent = parseFloat(bpmSlider.value).toFixed(0);
      densityLabel.textContent = parseFloat(densitySlider.value).toFixed(2);
      spaceLabel.textContent = parseFloat(spaceSlider.value).toFixed(2);
      stabilityLabel.textContent = parseFloat(stabilitySlider.value).toFixed(2);
      evolutionLabel.textContent = parseFloat(evolutionSlider.value).toFixed(2);

      if (Tone.Transport) {
        Tone.Transport.bpm.value = parseFloat(bpmSlider.value) || 70;
      }
    }

    bpmSlider.addEventListener("input", updateLabels);
    densitySlider.addEventListener("input", updateLabels);
    spaceSlider.addEventListener("input", updateLabels);
    stabilitySlider.addEventListener("input", updateLabels);
    evolutionSlider.addEventListener("input", updateLabels);

    updateLabels();
    statusText.textContent = "Idle. Press Start to begin.";
  </script>
</body>
</html>
