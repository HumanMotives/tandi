<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Better Ambient Generative Sequencer – Multi-lane v2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Tone.js -->
  <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>

  <style>
    /* Minimal styling, just to stay readable */
    body {
      margin: 0;
      padding: 20px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
    }
    h1 {
      font-size: 18px;
      margin-bottom: 4px;
    }
    p {
      font-size: 13px;
      line-height: 1.4;
      color: #ccc;
    }
    .row {
      margin-top: 16px;
      padding: 12px;
      border: 1px solid #333;
      border-radius: 6px;
    }
    label {
      display: block;
      font-size: 12px;
      margin-top: 8px;
      margin-bottom: 4px;
    }
    input[type="range"] {
      width: 100%;
    }
    button {
      margin-right: 8px;
      margin-top: 8px;
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      border-radius: 4px;
      border: 1px solid #555;
      background: #222;
      color: #eee;
    }
    button:active {
      background: #333;
    }
    .small {
      font-size: 11px;
      color: #aaa;
    }
    .status {
      font-size: 12px;
      margin-top: 6px;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <h1>Better Ambient Generative Sequencer – Multi-lane v2</h1>
  <p>
    Two lanes:<br>
    • <strong>Chord lane</strong> – strummed chords at phrase starts, no continuous drones.<br>
    • <strong>Melody lane</strong> – phrases mixing fast/short and slow/long notes.<br>
    Clocked to BPM, grid-based gaps. Space controls gaps for <em>both</em> chords and melody.
  </p>

  <div class="row">
    <button id="startStopBtn">Start</button>
    <button id="reseedBtn">Reseed motif / scale</button>
    <p class="small">
      Start: begins Transport-clocked bars.<br>
      Reseed: new scale + new base melody motif and chord behavior.
    </p>
  </div>

  <div class="row">
    <label for="bpmSlider">
      BPM (clock for both lanes):
      <span id="bpmLabel">70</span>
    </label>
    <input type="range" id="bpmSlider" min="40" max="120" step="1" value="70">

    <label for="densitySlider">
      Density — how much happens inside each melody phrase:
      <span id="densityLabel">0.60</span>
    </label>
    <input type="range" id="densitySlider" min="0" max="1" step="0.01" value="0.6">

    <label for="spaceSlider">
      Space — bars between phrases/chords (0 = frequent · 1 = rare):
      <span id="spaceLabel">0.40</span>
    </label>
    <input type="range" id="spaceSlider" min="0" max="1" step="0.01" value="0.4">

    <label for="stabilitySlider">
      Stability — harmonic stability (0 = roaming · 1 = anchored):
      <span id="stabilityLabel">0.70</span>
    </label>
    <input type="range" id="stabilitySlider" min="0" max="1" step="0.01" value="0.7">

    <label for="evolutionSlider">
      Evolution — 0 = same motif, 1 = constantly branching:
      <span id="evolutionLabel">0.40</span>
    </label>
    <input type="range" id="evolutionSlider" min="0" max="1" step="0.01" value="0.4">

    <p class="small">
      Density: notes per phrase & how “frilly” the rhythm is.<br>
      Space: how many bars between phrases (affects chords and melody).<br>
      Stability: how strongly chords gravitate around a center.<br>
      Evolution: motif mutation strength and how often new motifs appear.
    </p>
  </div>

  <div class="row">
    <div class="status" id="statusText"></div>
  </div>

  <script>
    // ---------- SCALES / HARMONIC SETUP ----------

    const scaleDefs = [
      { name: "C Ionian",    rootMidi: 48, degrees: [0, 2, 4, 5, 7, 9, 11] },
      { name: "D Dorian",    rootMidi: 50, degrees: [0, 2, 3, 5, 7, 9, 10] },
      { name: "F Lydian",    rootMidi: 53, degrees: [0, 2, 4, 6, 7, 9, 11] },
      { name: "G Mixolydian",rootMidi: 55, degrees: [0, 2, 4, 5, 7, 9, 10] }
    ];

    function randomChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function randomRange(min, max) {
      return min + Math.random() * (max - min);
    }

    // ---------- STATE ----------

    const state = {
      isRunning: false,
      barCount: 0,
      currentScaleIndex: 0,
      currentChordRootIndex: 0,   // degree index within scale
      baseMotif: null             // { rhythmBeats:[], contour:[], baseDegreeIndex }
    };

    // ---------- AUDIO ENGINE ----------

    let limiter, reverb, chordSynth, melodySynth;

    function getSecondsPerBeat() {
      const bpm = parseFloat(bpmSlider.value) || 70;
      return 60 / bpm;
    }

    function initAudio() {
      if (chordSynth) return;

      limiter = new Tone.Limiter(-8).toDestination();

      // Only reverb, no delay
      reverb = new Tone.Reverb({
        decay: 7,
        wet: 0.35
      }).connect(limiter);

      // Chord lane: soft pad-ish but only in hits, not continuous
      chordSynth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: "triangle" },
        envelope: {
          attack: 0.03,
          decay: 1.5,
          sustain: 0.5,
          release: 4.5
        }
      }).connect(reverb);
      chordSynth.volume.value = -12;

      // Melody lane: plucky marimba-ish
      const melodyFilter = new Tone.Filter({
        type: "lowpass",
        frequency: 4500,
        Q: 0.5
      }).connect(reverb);

      melodySynth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: "triangle" },
        envelope: {
          attack: 0.001,
          decay: 0.22,
          sustain: 0,
          release: 1.0
        }
      }).connect(melodyFilter);
      melodySynth.volume.value = -10;

      Tone.Transport.bpm.value = parseFloat(bpmSlider.value) || 70;
    }

    function getScale() {
      return scaleDefs[state.currentScaleIndex % scaleDefs.length];
    }

    // ---------- HARMONY: CHORD LANE ----------

    function chooseChordDegree(stability) {
      const scale = getScale();
      const len = scale.degrees.length;
      const current = state.currentChordRootIndex;
      const r = Math.random();

      if (Math.random() < stability) {
        if (r < 0.6) {
          return current; // stay
        } else if (r < 0.8) {
          return (current + 1) % len;
        } else {
          return (current + len - 1) % len;
        }
      } else {
        // roam: pick some other degree, slightly biased to mediant/submediant
        const candidates = [2, 4, 5, 1, 0, 6].map(i => i % len);
        const filtered = candidates.filter(d => d !== current);
        return randomChoice(filtered);
      }
    }

    function scheduleChordHit(time) {
      const scale = getScale();
      const degrees = scale.degrees;
      const rootMidi = scale.rootMidi;
      const secsPerBeat = getSecondsPerBeat();
      const stability = parseFloat(stabilitySlider.value);

      // Move harmonic center a bit when we actually play
      state.currentChordRootIndex = chooseChordDegree(stability);
      const degIndex = state.currentChordRootIndex;

      // triad or 7th/9th
      const chordDegreeOffsets = [0, 2, 4].map(d => (degIndex + d) % degrees.length);
      const use7th = Math.random() < 0.5;
      const use9th = Math.random() < 0.3;

      if (use7th) chordDegreeOffsets.push((degIndex + 6) % degrees.length);
      if (use9th) chordDegreeOffsets.push((degIndex + 1) % degrees.length);

      const chordNotes = [];

      // low root
      chordNotes.push(rootMidi + degrees[degIndex] - 12);

      // mid chord
      chordDegreeOffsets.forEach(idx => {
        chordNotes.push(rootMidi + degrees[idx]);
      });

      // occasional top color
      if (Math.random() < 0.5) {
        chordNotes.push(rootMidi + degrees[degIndex] + 12);
      }

      const unique = [...new Set(chordNotes)];

      // Strum chord: small offsets within ~30–90 ms
      const baseStrum = randomRange(0.03, 0.09);
      const durBeats = randomRange(2, 4);
      const durSec = durBeats * secsPerBeat;

      unique.forEach((midi, i) => {
        const offset = baseStrum * i;
        const freq = Tone.Midi(midi).toFrequency();
        const vel = randomRange(0.3, 0.6);
        chordSynth.triggerAttackRelease(freq, durSec, time + offset, vel);
      });
    }

    // ---------- MELODY LANE: MOTIFS / PHRASES ----------

    const contourTypes = ["up", "down", "arch", "zigzag"];

    function buildContour(len, type) {
      // Returns scale-degree offsets like [0,+1,+2,+1,0]
      const steps = [];

      if (type === "up") {
        let pos = 0;
        for (let i = 0; i < len; i++) {
          steps.push(pos);
          if (i < len - 1) pos += randomChoice([1, 1, 2]);
        }
      } else if (type === "down") {
        let pos = 0;
        for (let i = 0; i < len; i++) {
          steps.push(pos);
          if (i < len - 1) pos += randomChoice([-1, -1, -2]);
        }
      } else if (type === "arch") {
        const mid = Math.floor(len / 2);
        let pos = 0;
        for (let i = 0; i < len; i++) {
          steps.push(pos);
          if (i < mid) pos += randomChoice([1, 1, 2]);
          else if (i < len - 1) pos += randomChoice([-1, -1, -2]);
        }
      } else { // zigzag
        let pos = 0;
        let dir = 1;
        for (let i = 0; i < len; i++) {
          steps.push(pos);
          if (i < len - 1) {
            pos += dir * randomChoice([1, 2]);
            dir *= -1;
          }
        }
      }

      const start = steps[0];
      return steps.map(s => s - start);
    }

    function generateRhythmBeats(density) {
      // We generate durations that sum roughly 2–4 beats
      // and alternate long vs short for hook-like feel.

      const longDurOptionsLow = [1, 0.5];                 // quarter, eighth
      const longDurOptionsHigh = [0.5, 0.25];             // eighth, 16th
      const shortDurOptions = [0.25, 0.125, 0.0625];      // 16th, 32nd

      // target total beats
      const minTotal = 2;
      const maxTotal = 4;
      const targetTotal = randomRange(minTotal, maxTotal);

      // note count gets higher with density
      const minNotes = 3;
      const maxNotes = 12;
      let maxCount = Math.round(minNotes + density * (maxNotes - minNotes));

      const beats = [];
      let total = 0;
      let lastWasLong = Math.random() < 0.5;

      while (total < targetTotal && beats.length < maxCount) {
        const useLong = !lastWasLong && Math.random() < 0.7
          ? true
          : lastWasLong && Math.random() < 0.3
          ? false
          : !lastWasLong;

        let dur;
        if (useLong) {
          const longOptions =
            density < 0.5 ? longDurOptionsLow : longDurOptionsHigh;
          dur = randomChoice(longOptions);
        } else {
          dur = randomChoice(shortDurOptions);
        }

        if (total + dur > maxTotal + 0.25) break;

        beats.push(dur);
        total += dur;
        lastWasLong = useLong;
      }

      // Guarantee at least one long and one short if possible
      if (beats.length >= 3) {
        const hasShort = beats.some(b => b <= 0.25);
        const hasLong = beats.some(b => b >= 0.5);
        if (!hasShort) beats[beats.length - 1] = 0.25;
        if (!hasLong) beats[0] = 0.5;
      }

      return beats;
    }

    function createBaseMotif(density) {
      const scale = getScale();
      const degrees = scale.degrees;
      const rootIndex = state.currentChordRootIndex;

      const rhythmBeats = generateRhythmBeats(density);
      const contourType = randomChoice(contourTypes);
      const contour = buildContour(rhythmBeats.length, contourType);

      // anchor motif base roughly around chord degrees
      const chordDegrees = [0, 2, 4].map(d => (rootIndex + d) % degrees.length);
      const baseDegreeIndex = randomChoice(chordDegrees);

      return { rhythmBeats, contour, baseDegreeIndex };
    }

    function mutateMotif(baseMotif, evolution) {
      if (evolution <= 0.001) {
        return JSON.parse(JSON.stringify(baseMotif));
      }

      const clone = JSON.parse(JSON.stringify(baseMotif));

      // Small chance to completely refresh rhythm at higher evolution
      if (Math.random() < evolution * 0.5) {
        const density = parseFloat(densitySlider.value);
        clone.rhythmBeats = generateRhythmBeats(density);
      } else {
        // Otherwise, tweak existing durations
        clone.rhythmBeats = clone.rhythmBeats.map(d => {
          if (Math.random() < evolution * 0.6) {
            const factor = randomRange(0.7, 1.3);
            let nd = d * factor;
            // snap to nearest grid step
            const grid = [0.0625, 0.125, 0.25, 0.5, 1];
            let best = grid[0];
            let bestDiff = Math.abs(nd - grid[0]);
            for (let g of grid) {
              const diff = Math.abs(nd - g);
              if (diff < bestDiff) {
                bestDiff = diff;
                best = g;
              }
            }
            nd = best;
            return nd;
          }
          return d;
        });
      }

      // Tweak contour
      clone.contour = clone.contour.map(step => {
        if (Math.random() < evolution * 0.7) {
          return step + randomChoice([-1, 0, 1]);
        }
        return step;
      });

      // Chance to transpose motif base degree
      if (Math.random() < evolution * 0.6) {
        const shift = randomChoice([-2, -1, 1, 2]);
        const scale = getScale();
        const len = scale.degrees.length;
        clone.baseDegreeIndex =
          (clone.baseDegreeIndex + shift + len) % len;
      }

      return clone;
    }

    function shouldPlayThisBar() {
      const space = parseFloat(spaceSlider.value);
      // space=0 => p≈0.9, space=1 => p≈0.15
      const p = 0.9 - 0.75 * space;
      return Math.random() < p;
    }

    function scheduleMelodyPhrase(time) {
      const density = parseFloat(densitySlider.value);
      const evolution = parseFloat(evolutionSlider.value);
      const scale = getScale();
      const degrees = scale.degrees;
      const rootMidi = scale.rootMidi;
      const secsPerBeat = getSecondsPerBeat();

      if (!state.baseMotif) {
        state.baseMotif = createBaseMotif(density);
      }

      let motif = mutateMotif(state.baseMotif, evolution);

      // At high evolution, sometimes adopt mutated motif as new base
      if (evolution > 0.7 && Math.random() < (evolution - 0.7) * 1.5) {
        state.baseMotif = motif;
      }

      const { rhythmBeats, contour, baseDegreeIndex } = motif;

      let beatOffset = 0;
      for (let i = 0; i < rhythmBeats.length; i++) {
        const durBeats = rhythmBeats[i];
        const offsetBeats = beatOffset;

        const scaleDegreeIndex =
          (baseDegreeIndex + contour[i] + degrees.length) % degrees.length;
        const degreeOffset = degrees[scaleDegreeIndex];

        // Register selection: mostly mid/high, occasional low
        let octaveOffset;
        if (density < 0.5) {
          octaveOffset = randomChoice([0, 12]);
        } else {
          octaveOffset = randomChoice([0, 12, 24, -12]);
        }

        const midi = rootMidi + degreeOffset + octaveOffset;
        const freq = Tone.Midi(midi).toFrequency();

        const durSeconds = Math.max(
          0.1,
          durBeats * secsPerBeat * randomRange(0.9, 1.5)
        );

        const vel = randomRange(0.3, 0.75);

        melodySynth.triggerAttackRelease(
          freq,
          durSeconds,
          time + offsetBeats * secsPerBeat,
          vel
        );

        beatOffset += durBeats;
      }
    }

    // ---------- FORM / TRANSPORT ----------

    function describeSection(barCount) {
      const idx = Math.floor(barCount / 4) % 3; // rough segments
      if (idx === 0) return "A";
      if (idx === 1) return "B";
      return "A'";
    }

    function updateStatus(lastBarInfo) {
      const scale = getScale();
      const secsPerBeat = getSecondsPerBeat();
      const info = [
        `Scale: ${scale.name}`,
        `Bar: ${state.barCount}`,
        `Section (rough): ${describeSection(state.barCount)}`,
        `Chord degree index: ${state.currentChordRootIndex}`,
        `BPM: ${parseFloat(bpmSlider.value).toFixed(0)}`,
        `Density: ${parseFloat(densitySlider.value).toFixed(2)} · Space: ${parseFloat(spaceSlider.value).toFixed(2)}`,
        `Stability: ${parseFloat(stabilitySlider.value).toFixed(2)} · Evolution: ${parseFloat(evolutionSlider.value).toFixed(2)}`,
        `Seconds per beat: ${secsPerBeat.toFixed(3)}`,
        lastBarInfo
      ];
      statusText.textContent = info.join("\n");
    }

    function onBar(time) {
      if (!state.isRunning) return;

      const playThisBar = shouldPlayThisBar();
      let barInfo = "This bar: rest";

      if (playThisBar) {
        scheduleChordHit(time);
        scheduleMelodyPhrase(time);
        barInfo = "This bar: chord hit + melody phrase";
      }

      state.barCount += 1;
      updateStatus(barInfo);
    }

    // ---------- START / STOP / RESEED ----------

    async function startEngine() {
      if (state.isRunning) return;
      initAudio();
      await Tone.start();

      state.isRunning = true;
      state.barCount = 0;
      state.baseMotif = null;

      // random starting scale and chord degree
      state.currentScaleIndex = Math.floor(Math.random() * scaleDefs.length);
      state.currentChordRootIndex = Math.floor(Math.random() * getScale().degrees.length);

      Tone.Transport.cancel(); // clear previous events
      Tone.Transport.bpm.value = parseFloat(bpmSlider.value) || 70;

      Tone.Transport.scheduleRepeat(onBar, "1m");
      Tone.Transport.start("+0.05");
      updateStatus("Starting…");
    }

    function stopEngine() {
      state.isRunning = false;
      Tone.Transport.stop();
      Tone.Transport.cancel();
      statusText.textContent = "Stopped.";
    }

    function reseed() {
      state.currentScaleIndex = Math.floor(Math.random() * scaleDefs.length);
      state.baseMotif = null;
      state.barCount = 0;
      statusText.textContent += "\nReseed: new scale + motif.";
    }

    // ---------- UI BINDINGS ----------

    const startStopBtn = document.getElementById("startStopBtn");
    const reseedBtn = document.getElementById("reseedBtn");
    const bpmSlider = document.getElementById("bpmSlider");
    const densitySlider = document.getElementById("densitySlider");
    const spaceSlider = document.getElementById("spaceSlider");
    const stabilitySlider = document.getElementById("stabilitySlider");
    const evolutionSlider = document.getElementById("evolutionSlider");

    const bpmLabel = document.getElementById("bpmLabel");
    const densityLabel = document.getElementById("densityLabel");
    const spaceLabel = document.getElementById("spaceLabel");
    const stabilityLabel = document.getElementById("stabilityLabel");
    const evolutionLabel = document.getElementById("evolutionLabel");
    const statusText = document.getElementById("statusText");

    startStopBtn.addEventListener("click", () => {
      if (!state.isRunning) {
        startEngine().catch(console.error);
        startStopBtn.textContent = "Stop";
      } else {
        stopEngine();
        startStopBtn.textContent = "Start";
      }
    });

    reseedBtn.addEventListener("click", () => {
      reseed();
    });

    function updateLabels() {
      bpmLabel.textContent = parseFloat(bpmSlider.value).toFixed(0);
      densityLabel.textContent = parseFloat(densitySlider.value).toFixed(2);
      spaceLabel.textContent = parseFloat(spaceSlider.value).toFixed(2);
      stabilityLabel.textContent = parseFloat(stabilitySlider.value).toFixed(2);
      evolutionLabel.textContent = parseFloat(evolutionSlider.value).toFixed(2);

      if (Tone.Transport) {
        Tone.Transport.bpm.value = parseFloat(bpmSlider.value) || 70;
      }
    }

    bpmSlider.addEventListener("input", updateLabels);
    densitySlider.addEventListener("input", updateLabels);
    spaceSlider.addEventListener("input", updateLabels);
    stabilitySlider.addEventListener("input", updateLabels);
    evolutionSlider.addEventListener("input", updateLabels);

    updateLabels();
    statusText.textContent = "Idle. Press Start to begin.";
  </script>
</body>
</html>
