<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Better Ambient Generative Sequencer – Cluster Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Tone.js CDN -->
  <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>

  <style>
    /* Minimal styling only for readability */
    body {
      margin: 0;
      padding: 20px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
    }
    h1 {
      font-size: 18px;
      margin-bottom: 4px;
    }
    p {
      font-size: 13px;
      line-height: 1.4;
      color: #ccc;
    }
    .row {
      margin-top: 16px;
      padding: 12px;
      border: 1px solid #333;
      border-radius: 6px;
    }
    label {
      display: block;
      font-size: 12px;
      margin-top: 8px;
      margin-bottom: 4px;
    }
    input[type="range"] {
      width: 100%;
    }
    button {
      margin-right: 8px;
      margin-top: 8px;
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      border-radius: 4px;
      border: 1px solid #555;
      background: #222;
      color: #eee;
    }
    button:active {
      background: #333;
    }
    .small {
      font-size: 11px;
      color: #aaa;
    }
    .status {
      font-size: 12px;
      margin-top: 6px;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <h1>Better Ambient Generative Sequencer</h1>
  <p>
    Prototype focused on <strong>clusters</strong> of notes (motifs) with long gaps at low density,
    and a <strong>Symmetry</strong> control for how much the motif branches or evolves.
  </p>

  <div class="row">
    <button id="startStopBtn">Start</button>
    <button id="reseedBtn">Reseed motif</button>
    <p class="small">
      Start: begins a loop of phrase clusters + rests.  
      Reseed: creates a completely new base motif.
    </p>
  </div>

  <div class="row">
    <label for="densitySlider">
      Density (0 = rare, long gaps · 1 = near continuous clusters):
      <span id="densityLabel">0.20</span>
    </label>
    <input type="range" id="densitySlider" min="0" max="1" step="0.01" value="0.2">

    <label for="symmetrySlider">
      Symmetry (0 = identical motif forever · 1 = strong branching / evolution):
      <span id="symmetryLabel">0.30</span>
    </label>
    <input type="range" id="symmetrySlider" min="0" max="1" step="0.01" value="0.3">

    <label for="stabilitySlider">
      Stability (0 = roaming harmonic center · 1 = very anchored):
      <span id="stabilityLabel">0.70</span>
    </label>
    <input type="range" id="stabilitySlider" min="0" max="1" step="0.01" value="0.7">

    <p class="small">
      Density controls the <strong>time between clusters</strong> (2–10 seconds at low values,
      down to short gaps at high values).  
      Symmetry controls how much each repetition is mutated.  
      Stability controls how much the harmonic center moves around the scale.
    </p>
  </div>

  <div class="row">
    <div class="status" id="statusText"></div>
  </div>

  <script>
    // -------------------------
    // Engine state
    // -------------------------
    const state = {
      isRunning: false,
      cycleTimeoutId: null,
      basePhrase: null,          // base motif (array of note objects)
      phraseCount: 0,            // how many phrases have been played
      currentChordRootIndex: 0,  // index into scale for harmony center
    };

    // UI elements
    const startStopBtn = document.getElementById("startStopBtn");
    const reseedBtn = document.getElementById("reseedBtn");
    const densitySlider = document.getElementById("densitySlider");
    const symmetrySlider = document.getElementById("symmetrySlider");
    const stabilitySlider = document.getElementById("stabilitySlider");
    const densityLabel = document.getElementById("densityLabel");
    const symmetryLabel = document.getElementById("symmetryLabel");
    const stabilityLabel = document.getElementById("stabilityLabel");
    const statusText = document.getElementById("statusText");

    // -------------------------
    // Basic musical setup
    // -------------------------

    const rootMidi = 50; // D3
    const scaleDorian = [0, 2, 3, 5, 7, 9, 10]; // D Dorian scale degrees
    const chordNames = ["Dm", "Em", "F", "G", "Am", "B♭", "C"];

    let synth, reverb, delay;

    function initSynth() {
      if (synth) return;

      reverb = new Tone.Reverb({
        decay: 8,
        wet: 0.5
      }).toDestination();

      delay = new Tone.FeedbackDelay({
        delayTime: "8n",
        feedback: 0.45,
        wet: 0.35
      }).connect(reverb);

      synth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: "sine" },
        envelope: {
          attack: 0.15,
          decay: 2.0,
          sustain: 0.5,
          release: 4.0
        }
      }).connect(delay);
    }

    // Utility helpers
    function randomChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function randomRange(min, max) {
      return min + Math.random() * (max - min);
    }

    // Decide harmonic center movement based on stability
    function chooseChordRootIndex(stability) {
      const current = state.currentChordRootIndex;
      const r = Math.random();

      if (Math.random() < stability) {
        if (r < 0.6) {
          return current; // stay
        } else if (r < 0.8) {
          return (current + 1) % scaleDorian.length; // step up
        } else {
          return (current + scaleDorian.length - 1) % scaleDorian.length; // step down
        }
      } else {
        const options = [];
        for (let i = 0; i < scaleDorian.length; i++) {
          if (i !== current) options.push(i);
        }
        return randomChoice(options);
      }
    }

    // -------------------------
    // Motif (phrase) creation
    // -------------------------

    // Base motif: cluster of notes over 1–3 seconds
    function createBasePhrase() {
      const phrase = [];
      const phraseDuration = randomRange(1.2, 3.0); // seconds
      const noteCount = Math.floor(randomRange(3, 7)); // 3–6 notes

      // Pick harmonic center for this motif
      const rootIndex = state.currentChordRootIndex;
      const chordDegrees = [0, 2, 4].map(
        d => (rootIndex + d) % scaleDorian.length
      );
      const centerDegree = randomChoice(chordDegrees);

      // Generate times and pitches
      for (let i = 0; i < noteCount; i++) {
        const tNorm = i / Math.max(1, noteCount - 1); // 0..1
        let offset = tNorm * phraseDuration;

        // small jitter in time
        offset += randomRange(-0.1, 0.1);
        offset = Math.max(0, offset);

        // interval around center (small steps)
        const stepOffset = randomChoice([-2, -1, 0, 1, 2]);
        const degreeIndex =
          (centerDegree + stepOffset + scaleDorian.length) % scaleDorian.length;
        const degreeOffset = scaleDorian[degreeIndex];

        // choose octave range (mostly two octaves)
        const octaveOffset = randomChoice([0, 12, 12]);

        const midi = rootMidi + degreeOffset + octaveOffset;

        const vel = randomRange(0.35, 0.75);
        const dur = randomRange(0.4, 1.4); // seconds

        phrase.push({
          offsetSeconds: offset,
          midi,
          velocity: vel,
          durationSeconds: dur
        });
      }

      // Sort by time
      phrase.sort((a, b) => a.offsetSeconds - b.offsetSeconds);
      return phrase;
    }

    // Mutate phrase based on symmetry factor (0..1)
    function mutatePhrase(basePhrase, symmetry) {
      if (symmetry <= 0.001) {
        // exactly identical
        return basePhrase.map(n => ({ ...n }));
      }

      const mutated = basePhrase.map(note => {
        const n = { ...note };

        // time jitter proportional to symmetry
        const maxTimeJitter = 0.12 * symmetry; // seconds
        n.offsetSeconds = Math.max(
          0,
          n.offsetSeconds + randomRange(-maxTimeJitter, maxTimeJitter)
        );

        // pitch small changes
        if (Math.random() < symmetry * 0.9) {
          const semitoneShift = randomChoice([-2, -1, 1, 2, 0]);
          n.midi += semitoneShift;
        }

        // duration variation
        if (Math.random() < symmetry * 0.6) {
          const factor = randomRange(0.8, 1.3);
          n.durationSeconds = Math.max(0.1, n.durationSeconds * factor);
        }

        // velocity variation
        if (Math.random() < symmetry * 0.5) {
          n.velocity = Math.min(1, Math.max(0.1, n.velocity + randomRange(-0.15, 0.15)));
        }

        return n;
      });

      // sort again in case offsets changed order
      mutated.sort((a, b) => a.offsetSeconds - b.offsetSeconds);
      return mutated;
    }

    // -------------------------
    // Cluster scheduling
    // -------------------------

    function computeDurations(density) {
      // Phrase duration: 1–4 seconds depending slightly on density
      const phraseDuration = 1.0 + density * 3.0; // 1 → 4 seconds

      // Rest duration strongly controlled by density
      // density = 0  ->  rest between 2 and 10 s
      // density = 1  ->  rest between 0.2 and 1.5 s
      let restMin = 2.0 - 1.8 * density;
      let restMax = 10.0 - 8.5 * density;

      restMin = Math.max(0.2, restMin);
      restMax = Math.max(restMin + 0.1, restMax);

      const restDuration = randomRange(restMin, restMax);

      // At very low density, sometimes skip a phrase entirely (just rest)
      const silenceProb = (1 - density) * 0.5;

      return { phraseDuration, restDuration, silenceProb };
    }

    function describeSection(phraseCount) {
      // Just a rough A / B / A' feeling: 8 phrases per section
      const index = phraseCount % 24;
      if (index < 8) return "A";
      if (index < 16) return "B";
      return "A'";
    }

    function updateStatusText(info) {
      const lines = [
        `Phrase #: ${info.phraseCount}`,
        `Section (rough): ${info.section}`,
        `Chord center: ${info.chordName}`,
        `Density: ${info.density.toFixed(2)}  ·  Symmetry: ${info.symmetry.toFixed(2)}  ·  Stability: ${info.stability.toFixed(2)}`,
        `Phrase duration ~ ${info.phraseDuration.toFixed(1)}s  ·  Next rest ~ ${info.restDuration.toFixed(1)}s`,
        info.silence ? "This cycle: silence (no phrase, just rest)" : "This cycle: motif cluster played"
      ];
      statusText.textContent = lines.join("\n");
    }

    function scheduleNextCycle() {
      if (!state.isRunning) return;

      const density = parseFloat(densitySlider.value);
      const symmetry = parseFloat(symmetrySlider.value);
      const stability = parseFloat(stabilitySlider.value);

      const { phraseDuration, restDuration, silenceProb } = computeDurations(density);

      // update harmonic center before each "cycle"
      state.currentChordRootIndex = chooseChordRootIndex(stability);
      const chordName = chordNames[state.currentChordRootIndex];

      const willBeSilent = Math.random() < silenceProb;

      const now = Tone.now();
      let effectivePhraseDuration = 0;

      if (!willBeSilent) {
        // Ensure we have a base phrase
        if (!state.basePhrase) {
          state.basePhrase = createBasePhrase();
        }

        // Mutate based on symmetry
        const phraseToPlay = mutatePhrase(state.basePhrase, symmetry);

        // At high symmetry, occasionally let the mutation become the new base (branching)
        if (symmetry > 0.7 && Math.random() < 0.3) {
          state.basePhrase = phraseToPlay.map(n => ({ ...n }));
        }

        // Schedule all notes in this phrase
        for (const note of phraseToPlay) {
          const startTime = now + note.offsetSeconds;
          const duration = note.durationSeconds;
          const freq = Tone.Midi(note.midi).toFrequency();
          synth.triggerAttackRelease(freq, duration, startTime, note.velocity);
          effectivePhraseDuration = Math.max(
            effectivePhraseDuration,
            note.offsetSeconds + note.durationSeconds
          );
        }
      }

      state.phraseCount += willBeSilent ? 0 : 1;

      const sectionId = describeSection(state.phraseCount);

      updateStatusText({
        phraseCount: state.phraseCount,
        section: sectionId,
        chordName,
        density,
        symmetry,
        stability,
        phraseDuration: willBeSilent ? 0 : effectivePhraseDuration || phraseDuration,
        restDuration,
        silence: willBeSilent
      });

      // Next cycle: phraseDuration (if any) + restDuration
      const totalDelay = (willBeSilent ? 0 : (effectivePhraseDuration || phraseDuration)) + restDuration;

      state.cycleTimeoutId = setTimeout(() => {
        scheduleNextCycle();
      }, totalDelay * 1000);
    }

    // -------------------------
    // Start / stop / reseed
    // -------------------------

    async function startEngine() {
      if (state.isRunning) return;
      initSynth();
      await Tone.start();

      state.isRunning = true;
      state.phraseCount = 0;
      state.basePhrase = null;
      statusText.textContent = "Starting…";

      scheduleNextCycle();
    }

    function stopEngine() {
      state.isRunning = false;
      if (state.cycleTimeoutId !== null) {
        clearTimeout(state.cycleTimeoutId);
        state.cycleTimeoutId = null;
      }
      statusText.textContent = "Stopped.";
    }

    function reseedMotif() {
      state.basePhrase = null;
      state.phraseCount = 0;
      statusText.textContent += "\nMotif reseeded.";
    }

    // -------------------------
    // UI bindings
    // -------------------------

    startStopBtn.addEventListener("click", () => {
      if (!state.isRunning) {
        startEngine().catch(console.error);
        startStopBtn.textContent = "Stop";
      } else {
        stopEngine();
        startStopBtn.textContent = "Start";
      }
    });

    reseedBtn.addEventListener("click", () => {
      reseedMotif();
    });

    function updateLabels() {
      densityLabel.textContent = parseFloat(densitySlider.value).toFixed(2);
      symmetryLabel.textContent = parseFloat(symmetrySlider.value).toFixed(2);
      stabilityLabel.textContent = parseFloat(stabilitySlider.value).toFixed(2);
    }

    densitySlider.addEventListener("input", updateLabels);
    symmetrySlider.addEventListener("input", updateLabels);
    stabilitySlider.addEventListener("input", updateLabels);

    updateLabels();
    statusText.textContent = "Idle. Press Start to begin.";
  </script>
</body>
</html>
