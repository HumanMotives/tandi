<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Better Ambient Generative Sequencer – Cluster Prototype v0.2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Tone.js CDN -->
  <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>

  <style>
    /* Minimal styling only for readability */
    body {
      margin: 0;
      padding: 20px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
    }
    h1 {
      font-size: 18px;
      margin-bottom: 4px;
    }
    p {
      font-size: 13px;
      line-height: 1.4;
      color: #ccc;
    }
    .row {
      margin-top: 16px;
      padding: 12px;
      border: 1px solid #333;
      border-radius: 6px;
    }
    label {
      display: block;
      font-size: 12px;
      margin-top: 8px;
      margin-bottom: 4px;
    }
    input[type="range"] {
      width: 100%;
    }
    button {
      margin-right: 8px;
      margin-top: 8px;
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      border-radius: 4px;
      border: 1px solid #555;
      background: #222;
      color: #eee;
    }
    button:active {
      background: #333;
    }
    .small {
      font-size: 11px;
      color: #aaa;
    }
    .status {
      font-size: 12px;
      margin-top: 6px;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <h1>Better Ambient Generative Sequencer</h1>
  <p>
    Prototype focused on <strong>motif clusters</strong> with long controllable gaps (Space),
    quantised rhythmic shapes, and an <strong>Evolution</strong> parameter that branches from
    a base motif.
  </p>

  <div class="row">
    <button id="startStopBtn">Start</button>
    <button id="reseedBtn">Reseed motif</button>
    <p class="small">
      Start: begins a loop of motif clusters + rests.<br>
      Reseed: creates a completely new base motif.
    </p>
  </div>

  <div class="row">
    <label for="densitySlider">
      Density — how much happens inside each cluster (notes & spacing):
      <span id="densityLabel">0.30</span>
    </label>
    <input type="range" id="densitySlider" min="0" max="1" step="0.01" value="0.3">

    <label for="spaceSlider">
      Space — gaps between clusters (0 = almost continuous · 1 = big gaps):
      <span id="spaceLabel">0.40</span>
    </label>
    <input type="range" id="spaceSlider" min="0" max="1" step="0.01" value="0.4">

    <label for="stabilitySlider">
      Stability — harmonic stability (0 = roaming · 1 = anchored):
      <span id="stabilityLabel">0.70</span>
    </label>
    <input type="range" id="stabilitySlider" min="0" max="1" step="0.01" value="0.7">

    <label for="evolutionSlider">
      Evolution — 0 = no change, 1 = continuous branching / new ideas:
      <span id="evolutionLabel">0.40</span>
    </label>
    <input type="range" id="evolutionSlider" min="0" max="1" step="0.01" value="0.4">

    <p class="small">
      Density: how many notes and how tightly they are packed in a cluster.<br>
      Space: how long to wait between clusters, including possible full silences.<br>
      Stability: how much the harmonic center moves around the scale.<br>
      Evolution: how strongly each repetition mutates the motif (0 = identical loop).
    </p>
  </div>

  <div class="row">
    <div class="status" id="statusText"></div>
  </div>

  <script>
    // -------------------------
    // Engine state
    // -------------------------
    const state = {
      isRunning: false,
      cycleTimeoutId: null,
      basePhrase: null,          // base motif (array of note objects)
      phraseCount: 0,            // how many phrases have been played
      currentChordRootIndex: 0,  // index into scale for harmony center
    };

    // UI elements
    const startStopBtn = document.getElementById("startStopBtn");
    const reseedBtn = document.getElementById("reseedBtn");
    const densitySlider = document.getElementById("densitySlider");
    const spaceSlider = document.getElementById("spaceSlider");
    const stabilitySlider = document.getElementById("stabilitySlider");
    const evolutionSlider = document.getElementById("evolutionSlider");

    const densityLabel = document.getElementById("densityLabel");
    const spaceLabel = document.getElementById("spaceLabel");
    const stabilityLabel = document.getElementById("stabilityLabel");
    const evolutionLabel = document.getElementById("evolutionLabel");
    const statusText = document.getElementById("statusText");

    // -------------------------
    // Basic musical setup
    // -------------------------
    const bpm = 70;
    const secondsPerBeat = 60 / bpm;

    const rootMidi = 50; // D3
    const scaleDorian = [0, 2, 3, 5, 7, 9, 10]; // D Dorian scale degrees
    const chordNames = ["Dm", "Em", "F", "G", "Am", "B♭", "C"];

    let synth, reverb, delay;

    function initSynth() {
      if (synth) return;

      reverb = new Tone.Reverb({
        decay: 8,
        wet: 0.5
      }).toDestination();

      delay = new Tone.FeedbackDelay({
        delayTime: "8n",
        feedback: 0.45,
        wet: 0.35
      }).connect(reverb);

      synth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: "sine" },
        envelope: {
          attack: 0.15,
          decay: 2.0,
          sustain: 0.5,
          release: 4.0
        }
      }).connect(delay);
    }

    // Utility helpers
    function randomChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function randomRange(min, max) {
      return min + Math.random() * (max - min);
    }

    // Harmonic center movement based on stability
    function chooseChordRootIndex(stability) {
      const current = state.currentChordRootIndex;
      const r = Math.random();

      if (Math.random() < stability) {
        if (r < 0.6) {
          return current; // stay
        } else if (r < 0.8) {
          return (current + 1) % scaleDorian.length; // step up
        } else {
          return (current + scaleDorian.length - 1) % scaleDorian.length; // step down
        }
      } else {
        const options = [];
        for (let i = 0; i < scaleDorian.length; i++) {
          if (i !== current) options.push(i);
        }
        return randomChoice(options);
      }
    }

    // -------------------------
    // Durations from Space
    // -------------------------

    function computeRest(space) {
      // At space = 0: short gaps (0.2–1.5 s), almost continuous
      // At space = 1: long gaps (2–10+ s)
      let restMin = 0.2 + 1.8 * space;
      let restMax = 1.5 + 8.5 * space;

      restMin = Math.max(0.2, restMin);
      restMax = Math.max(restMin + 0.1, restMax);

      // More space -> higher chance of skipping an entire phrase (pure silence)
      const silenceProb = 0.1 + 0.4 * space;

      return { restDuration: randomRange(restMin, restMax), silenceProb };
    }

    // -------------------------
    // Motif (phrase) creation
    // -------------------------

    // Base motif: cluster of notes with quantised rhythmic steps
    function createBasePhrase(density) {
      const phrase = [];

      // note count: 2–8 depending on density
      const minNotes = 2;
      const maxAdditional = 6; // up to 8 total
      const noteCount = Math.max(
        minNotes,
        Math.round(minNotes + density * maxAdditional)
      );

      // step durations in beats
      const slowSteps = [1, 0.5];                // quarter, eighth
      const midSteps  = [0.5, 0.25];             // eighth, sixteenth
      const fastSteps = [0.25, 0.125, 0.0625];   // 16th, 32nd

      let stepPool;

      if (density < 0.3) {
        stepPool = slowSteps;
      } else if (density < 0.7) {
        stepPool = slowSteps.concat(midSteps);
      } else {
        stepPool = midSteps.concat(fastSteps);
      }

      // Pick harmonic center for this motif
      const rootIndex = state.currentChordRootIndex;
      const chordDegrees = [0, 2, 4].map(
        d => (rootIndex + d) % scaleDorian.length
      );
      const centerDegree = randomChoice(chordDegrees);

      let currentTime = 0;

      for (let i = 0; i < noteCount; i++) {
        const stepBeats = randomChoice(stepPool);
        currentTime += stepBeats * secondsPerBeat;

        // small jitter in time
        const jitter = randomRange(-0.03, 0.03);
        const offsetSeconds = Math.max(0, currentTime + jitter);

        // pitch movement around center (small steps)
        const stepOffset = randomChoice([-2, -1, 0, 1, 2]);
        const degreeIndex =
          (centerDegree + stepOffset + scaleDorian.length) % scaleDorian.length;
        const degreeOffset = scaleDorian[degreeIndex];

        // choose octave range (mostly two octaves, sometimes a jump)
        let octaveOffset;
        if (density < 0.5) {
          octaveOffset = randomChoice([0, 12]);
        } else {
          octaveOffset = randomChoice([0, 12, 24, -12]);
        }

        const midi = rootMidi + degreeOffset + octaveOffset;

        // durations loosely tied to rhythm length, scaled to seconds
        const durBeats = stepBeats * randomRange(0.8, 1.6);
        const durationSeconds = Math.max(0.15, durBeats * secondsPerBeat);

        const velocity = randomRange(0.35, 0.75);

        phrase.push({
          offsetSeconds,
          midi,
          velocity,
          durationSeconds
        });
      }

      // Sort by time
      phrase.sort((a, b) => a.offsetSeconds - b.offsetSeconds);
      return phrase;
    }

    // Mutate phrase based on evolution factor (0..1)
    function mutatePhrase(basePhrase, evolution) {
      if (evolution <= 0.001) {
        // exactly identical copy
        return basePhrase.map(n => ({ ...n }));
      }

      const mutated = basePhrase.map(note => {
        const n = { ...note };

        // time jitter proportional to evolution
        const maxTimeJitter = 0.12 * evolution; // seconds
        n.offsetSeconds = Math.max(
          0,
          n.offsetSeconds + randomRange(-maxTimeJitter, maxTimeJitter)
        );

        // pitch changes
        if (Math.random() < evolution * 0.9) {
          const semitoneShift = randomChoice([-2, -1, 1, 2, 0]);
          n.midi += semitoneShift;
        }

        // duration variation
        if (Math.random() < evolution * 0.7) {
          const factor = randomRange(0.8, 1.3);
          n.durationSeconds = Math.max(0.1, n.durationSeconds * factor);
        }

        // velocity variation
        if (Math.random() < evolution * 0.6) {
          n.velocity = Math.min(1, Math.max(0.1, n.velocity + randomRange(-0.15, 0.15)));
        }

        return n;
      });

      // At high evolution, sometimes let the new mutation become the new base (branching)
      if (evolution > 0.7 && Math.random() < (evolution - 0.7) * 1.5) {
        state.basePhrase = mutated.map(n => ({ ...n }));
      }

      mutated.sort((a, b) => a.offsetSeconds - b.offsetSeconds);
      return mutated;
    }

    // -------------------------
    // Rough section feeling (A / B / A')
    // -------------------------

    function describeSection(phraseCount) {
      const index = phraseCount % 24;
      if (index < 8) return "A";
      if (index < 16) return "B";
      return "A'";
    }

    function updateStatusText(info) {
      const lines = [
        `Phrase #: ${info.phraseCount}`,
        `Section (rough): ${info.section}`,
        `Chord center: ${info.chordName}`,
        `Density: ${info.density.toFixed(2)}  ·  Space: ${info.space.toFixed(2)}`,
        `Stability: ${info.stability.toFixed(2)}  ·  Evolution: ${info.evolution.toFixed(2)}`,
        `Phrase duration ~ ${info.phraseDuration.toFixed(1)}s  ·  Next rest ~ ${info.restDuration.toFixed(1)}s`,
        info.silence ? "This cycle: silence (no phrase, just rest)" : "This cycle: motif cluster played"
      ];
      statusText.textContent = lines.join("\n");
    }

    // -------------------------
    // Cluster scheduling
    // -------------------------

    function scheduleNextCycle() {
      if (!state.isRunning) return;

      const density = parseFloat(densitySlider.value);
      const space = parseFloat(spaceSlider.value);
      const stability = parseFloat(stabilitySlider.value);
      const evolution = parseFloat(evolutionSlider.value);

      const { restDuration, silenceProb } = computeRest(space);

      // update harmonic center before each cycle
      state.currentChordRootIndex = chooseChordRootIndex(stability);
      const chordName = chordNames[state.currentChordRootIndex];

      const willBeSilent = Math.random() < silenceProb;

      const now = Tone.now();
      let effectivePhraseDuration = 0;

      if (!willBeSilent) {
        // Ensure we have a base phrase
        if (!state.basePhrase) {
          state.basePhrase = createBasePhrase(density);
        }

        // Mutate based on evolution
        const phraseToPlay = mutatePhrase(state.basePhrase, evolution);

        // At very high evolution, occasionally throw away base and create a fresh motif
        if (evolution > 0.9 && Math.random() < 0.4) {
          state.basePhrase = createBasePhrase(density);
        }

        // Schedule all notes in this phrase
        for (const note of phraseToPlay) {
          const startTime = now + note.offsetSeconds;
          const duration = note.durationSeconds;
          const freq = Tone.Midi(note.midi).toFrequency();
          synth.triggerAttackRelease(freq, duration, startTime, note.velocity);
          effectivePhraseDuration = Math.max(
            effectivePhraseDuration,
            note.offsetSeconds + note.durationSeconds
          );
        }

        state.phraseCount += 1;
      }

      const sectionId = describeSection(state.phraseCount);

      updateStatusText({
        phraseCount: state.phraseCount,
        section: sectionId,
        chordName,
        density,
        space,
        stability,
        evolution,
        phraseDuration: willBeSilent ? 0 : effectivePhraseDuration || 0,
        restDuration,
        silence: willBeSilent
      });

      const totalDelay = (willBeSilent ? 0 : (effectivePhraseDuration || 0)) + restDuration;

      state.cycleTimeoutId = setTimeout(() => {
        scheduleNextCycle();
      }, totalDelay * 1000);
    }

    // -------------------------
    // Start / stop / reseed
    // -------------------------

    async function startEngine() {
      if (state.isRunning) return;
      initSynth();
      await Tone.start();

      state.isRunning = true;
      state.phraseCount = 0;
      state.basePhrase = null;
      statusText.textContent = "Starting…";

      scheduleNextCycle();
    }

    function stopEngine() {
      state.isRunning = false;
      if (state.cycleTimeoutId !== null) {
        clearTimeout(state.cycleTimeoutId);
        state.cycleTimeoutId = null;
      }
      statusText.textContent = "Stopped.";
    }

    function reseedMotif() {
      state.basePhrase = null;
      state.phraseCount = 0;
      statusText.textContent += "\nMotif reseeded.";
    }

    // -------------------------
    // UI bindings
    // -------------------------

    startStopBtn.addEventListener("click", () => {
      if (!state.isRunning) {
        startEngine().catch(console.error);
        startStopBtn.textContent = "Stop";
      } else {
        stopEngine();
        startStopBtn.textContent = "Start";
      }
    });

    reseedBtn.addEventListener("click", () => {
      reseedMotif();
    });

    function updateLabels() {
      densityLabel.textContent = parseFloat(densitySlider.value).toFixed(2);
      spaceLabel.textContent = parseFloat(spaceSlider.value).toFixed(2);
      stabilityLabel.textContent = parseFloat(stabilitySlider.value).toFixed(2);
      evolutionLabel.textContent = parseFloat(evolutionSlider.value).toFixed(2);
    }

    densitySlider.addEventListener("input", updateLabels);
    spaceSlider.addEventListener("input", updateLabels);
    stabilitySlider.addEventListener("input", updateLabels);
    evolutionSlider.addEventListener("input", updateLabels);

    updateLabels();
    statusText.textContent = "Idle. Press Start to begin.";
  </script>
</body>
</html>
