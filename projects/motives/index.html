<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Better Ambient Generative Sequencer – Cluster Prototype v0.3</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Tone.js CDN -->
  <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>

  <style>
    /* Minimal styling only for readability */
    body {
      margin: 0;
      padding: 20px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
    }
    h1 {
      font-size: 18px;
      margin-bottom: 4px;
    }
    p {
      font-size: 13px;
      line-height: 1.4;
      color: #ccc;
    }
    .row {
      margin-top: 16px;
      padding: 12px;
      border: 1px solid #333;
      border-radius: 6px;
    }
    label {
      display: block;
      font-size: 12px;
      margin-top: 8px;
      margin-bottom: 4px;
    }
    input[type="range"] {
      width: 100%;
    }
    button {
      margin-right: 8px;
      margin-top: 8px;
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      border-radius: 4px;
      border: 1px solid #555;
      background: #222;
      color: #eee;
    }
    button:active {
      background: #333;
    }
    .small {
      font-size: 11px;
      color: #aaa;
    }
    .status {
      font-size: 12px;
      margin-top: 6px;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <h1>Better Ambient Generative Sequencer</h1>
  <p>
    Prototype focused on <strong>motif clusters</strong> with clocked rhythms and quantised gaps.
    Density controls activity inside each cluster, Space controls grid-aligned rests, Stability is
    harmonic, and Evolution controls how fast the motif branches.
  </p>

  <div class="row">
    <button id="startStopBtn">Start</button>
    <button id="reseedBtn">Reseed motif / scale</button>
    <p class="small">
      Start: begins a loop of motif clusters + rests.<br>
      Reseed: creates a new base motif and picks a new scale.
    </p>
  </div>

  <div class="row">
    <label for="bpmSlider">
      BPM (internal clock for motif rhythm and gaps):
      <span id="bpmLabel">70</span>
    </label>
    <input type="range" id="bpmSlider" min="40" max="120" step="1" value="70">

    <label for="densitySlider">
      Density — how much happens inside each cluster (notes & spacing):
      <span id="densityLabel">0.30</span>
    </label>
    <input type="range" id="densitySlider" min="0" max="1" step="0.01" value="0.3">

    <label for="spaceSlider">
      Space — grid-aligned gaps between clusters (0 = short · 1 = long):
      <span id="spaceLabel">0.40</span>
    </label>
    <input type="range" id="spaceSlider" min="0" max="1" step="0.01" value="0.4">

    <label for="stabilitySlider">
      Stability — harmonic stability (0 = roaming · 1 = anchored):
      <span id="stabilityLabel">0.70</span>
    </label>
    <input type="range" id="stabilitySlider" min="0" max="1" step="0.01" value="0.7">

    <label for="evolutionSlider">
      Evolution — 0 = no change, 1 = continuous branching / new ideas:
      <span id="evolutionLabel">0.40</span>
    </label>
    <input type="range" id="evolutionSlider" min="0" max="1" step="0.01" value="0.4">

    <p class="small">
      Density: how many notes and how tightly they are packed in a cluster.<br>
      Space: how many beats / bars to wait between clusters (quantised).<br>
      Stability: how much the harmonic center moves around the current scale.<br>
      Evolution: how strongly each repetition mutates the motif (0 = identical loop).
    </p>
  </div>

  <div class="row">
    <div class="status" id="statusText"></div>
  </div>

  <script>
    // -------------------------
    // Scales and modes
    // -------------------------
    const scaleDefs = [
      {
        name: "C Ionian",
        rootMidi: 48, // C3
        degrees: [0, 2, 4, 5, 7, 9, 11]
      },
      {
        name: "D Dorian",
        rootMidi: 50, // D3
        degrees: [0, 2, 3, 5, 7, 9, 10]
      },
      {
        name: "F Lydian",
        rootMidi: 53, // F3
        degrees: [0, 2, 4, 6, 7, 9, 11]
      },
      {
        name: "G Mixolydian",
        rootMidi: 55, // G3
        degrees: [0, 2, 4, 5, 7, 9, 10]
      }
    ];

    // -------------------------
    // Engine state
    // -------------------------
    const state = {
      isRunning: false,
      cycleTimeoutId: null,
      basePhrase: null,          // base motif (array of note objects)
      phraseCount: 0,            // how many phrases have been played
      currentChordRootIndex: 0,  // index into scale for harmony center
      currentScaleIndex: 1       // start with D Dorian by default
    };

    // UI elements
    const startStopBtn = document.getElementById("startStopBtn");
    const reseedBtn = document.getElementById("reseedBtn");

    const bpmSlider = document.getElementById("bpmSlider");
    const densitySlider = document.getElementById("densitySlider");
    const spaceSlider = document.getElementById("spaceSlider");
    const stabilitySlider = document.getElementById("stabilitySlider");
    const evolutionSlider = document.getElementById("evolutionSlider");

    const bpmLabel = document.getElementById("bpmLabel");
    const densityLabel = document.getElementById("densityLabel");
    const spaceLabel = document.getElementById("spaceLabel");
    const stabilityLabel = document.getElementById("stabilityLabel");
    const evolutionLabel = document.getElementById("evolutionLabel");
    const statusText = document.getElementById("statusText");

    // -------------------------
    // Basic musical / audio setup
    // -------------------------
    function getSecondsPerBeat() {
      const bpm = parseFloat(bpmSlider.value) || 70;
      return 60 / bpm;
    }

    let synth, reverb, delay, limiter;

    function initSynth() {
      if (synth) return;

      limiter = new Tone.Limiter(-8).toDestination();

      reverb = new Tone.Reverb({
        decay: 8,
        wet: 0.4
      }).connect(limiter);

      delay = new Tone.FeedbackDelay({
        delayTime: "8n",
        feedback: 0.35,
        wet: 0.3
      }).connect(reverb);

      synth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: "sine" },
        envelope: {
          attack: 0.15,
          decay: 2.0,
          sustain: 0.5,
          release: 4.0
        }
      }).connect(delay);

      // Lower overall synth level to avoid reverb overload
      synth.volume.value = -10;

      Tone.Transport.bpm.value = parseFloat(bpmSlider.value) || 70;
    }

    function getScale() {
      return scaleDefs[state.currentScaleIndex % scaleDefs.length];
    }

    // Utility helpers
    function randomChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function randomRange(min, max) {
      return min + Math.random() * (max - min);
    }

    // Harmonic center movement based on stability
    function chooseChordRootIndex(stability) {
      const scale = getScale();
      const length = scale.degrees.length;
      const current = state.currentChordRootIndex;
      const r = Math.random();

      if (Math.random() < stability) {
        if (r < 0.6) {
          return current; // stay
        } else if (r < 0.8) {
          return (current + 1) % length; // step up
        } else {
          return (current + length - 1) % length; // step down
        }
      } else {
        const options = [];
        for (let i = 0; i < length; i++) {
          if (i !== current) options.push(i);
        }
        return randomChoice(options);
      }
    }

    // -------------------------
    // Space -> rest in beats
    // -------------------------
    function computeRestBeats(space) {
      // Quantised rest choices
      const shortRests = [0.25, 0.5, 1];   // 16th, 8th, quarter
      const mediumRests = [1, 2, 4];       // quarter, half, whole
      const longRests = [4, 8, 16];        // 1 bar, 2 bars, 4 bars

      let pool;
      if (space < 0.33) {
        pool = shortRests;
      } else if (space < 0.66) {
        pool = mediumRests;
      } else {
        pool = longRests;
      }

      const restBeats = randomChoice(pool);
      // More space -> higher chance of skipping an entire phrase (pure silence)
      const silenceProb = 0.05 + 0.45 * space;

      return { restBeats, silenceProb };
    }

    // -------------------------
    // Motif (phrase) creation
    // -------------------------

    // Base motif: cluster of notes with quantised rhythmic steps
    function createBasePhrase(density) {
      const scale = getScale();
      const rootMidi = scale.rootMidi;
      const degrees = scale.degrees;
      const secsPerBeat = getSecondsPerBeat();

      const phrase = [];

      // note count: 2–8 depending on density
      const minNotes = 2;
      const maxAdditional = 6; // up to 8 total
      const noteCount = Math.max(
        minNotes,
        Math.round(minNotes + density * maxAdditional)
      );

      // step durations in beats
      const slowSteps = [1, 0.5];                // quarter, eighth
      const midSteps  = [0.5, 0.25];             // eighth, sixteenth
      const fastSteps = [0.25, 0.125, 0.0625];   // 16th, 32nd

      let stepPool;
      if (density < 0.3) {
        stepPool = slowSteps;
      } else if (density < 0.7) {
        stepPool = slowSteps.concat(midSteps);
      } else {
        stepPool = midSteps.concat(fastSteps);
      }

      // Pick harmonic center degree for this motif
      const rootIndex = state.currentChordRootIndex;
      const chordDegreesIndices = [0, 2, 4].map(
        d => (rootIndex + d) % degrees.length
      );
      const centerDegreeIndex = randomChoice(chordDegreesIndices);

      let currentBeats = 0;

      for (let i = 0; i < noteCount; i++) {
        const stepBeats = randomChoice(stepPool);
        currentBeats += stepBeats;

        // small jitter in time
        const jitter = randomRange(-0.03, 0.03);
        const offsetSeconds = Math.max(0, currentBeats * secsPerBeat + jitter);

        // pitch movement around center (small steps)
        const stepOffset = randomChoice([-2, -1, 0, 1, 2]);
        const degreeIndex =
          (centerDegreeIndex + stepOffset + degrees.length) % degrees.length;
        const degreeOffset = degrees[degreeIndex];

        // choose octave range
        let octaveOffset;
        if (density < 0.5) {
          octaveOffset = randomChoice([0, 12]);
        } else {
          octaveOffset = randomChoice([0, 12, 24, -12]);
        }

        const midi = rootMidi + degreeOffset + octaveOffset;

        // durations tied loosely to rhythm step
        const durBeats = stepBeats * randomRange(0.8, 1.6);
        const durationSeconds = Math.max(0.15, durBeats * secsPerBeat);

        const velocity = randomRange(0.25, 0.6);

        phrase.push({
          offsetSeconds,
          midi,
          velocity,
          durationSeconds
        });
      }

      phrase.sort((a, b) => a.offsetSeconds - b.offsetSeconds);
      return phrase;
    }

    // Mutate phrase based on evolution factor (0..1)
    function mutatePhrase(basePhrase, evolution) {
      if (evolution <= 0.001) {
        // exactly identical copy
        return basePhrase.map(n => ({ ...n }));
      }

      const mutated = basePhrase.map(note => {
        const n = { ...note };

        // time jitter proportional to evolution
        const maxTimeJitter = 0.12 * evolution; // seconds
        n.offsetSeconds = Math.max(
          0,
          n.offsetSeconds + randomRange(-maxTimeJitter, maxTimeJitter)
        );

        // pitch changes
        if (Math.random() < evolution * 0.9) {
          const semitoneShift = randomChoice([-2, -1, 1, 2, 0]);
          n.midi += semitoneShift;
        }

        // duration variation
        if (Math.random() < evolution * 0.7) {
          const factor = randomRange(0.8, 1.3);
          n.durationSeconds = Math.max(0.1, n.durationSeconds * factor);
        }

        // velocity variation
        if (Math.random() < evolution * 0.6) {
          n.velocity = Math.min(1, Math.max(0.1, n.velocity + randomRange(-0.15, 0.15)));
        }

        return n;
      });

      // At high evolution, sometimes let the new mutation become the new base (branching)
      if (evolution > 0.7 && Math.random() < (evolution - 0.7) * 1.5) {
        state.basePhrase = mutated.map(n => ({ ...n }));
      }

      mutated.sort((a, b) => a.offsetSeconds - b.offsetSeconds);
      return mutated;
    }

    // Rough section feeling (A / B / A')
    function describeSection(phraseCount) {
      const index = phraseCount % 24;
      if (index < 8) return "A";
      if (index < 16) return "B";
      return "A'";
    }

    function updateStatusText(info) {
      const lines = [
        `Scale: ${info.scaleName}`,
        `Phrase #: ${info.phraseCount}`,
        `Section (rough): ${info.section}`,
        `Center degree: ${info.centerDegree}`,
        `Density: ${info.density.toFixed(2)}  ·  Space: ${info.space.toFixed(2)}`,
        `Stability: ${info.stability.toFixed(2)}  ·  Evolution: ${info.evolution.toFixed(2)}  ·  BPM: ${info.bpm}`,
        `Phrase duration ~ ${info.phraseDuration.toFixed(1)}s  ·  Next rest ~ ${info.restDuration.toFixed(1)}s`,
        info.silence ? "This cycle: silence (no phrase, just rest)" : "This cycle: motif cluster played"
      ];
      statusText.textContent = lines.join("\n");
    }

    // -------------------------
    // Cluster scheduling
    // -------------------------

    function scheduleNextCycle() {
      if (!state.isRunning) return;

      const density = parseFloat(densitySlider.value);
      const space = parseFloat(spaceSlider.value);
      const stability = parseFloat(stabilitySlider.value);
      const evolution = parseFloat(evolutionSlider.value);
      const bpm = parseFloat(bpmSlider.value) || 70;
      const secsPerBeat = getSecondsPerBeat();

      const { restBeats, silenceProb } = computeRestBeats(space);

      // update harmonic center before each cycle
      state.currentChordRootIndex = chooseChordRootIndex(stability);
      const scale = getScale();
      const centerDegree = state.currentChordRootIndex + 1;

      const willBeSilent = Math.random() < silenceProb;

      const now = Tone.now();
      let effectivePhraseDuration = 0;

      if (!willBeSilent) {
        // Ensure we have a base phrase
        if (!state.basePhrase) {
          state.basePhrase = createBasePhrase(density);
        }

        // Mutate based on evolution
        const phraseToPlay = mutatePhrase(state.basePhrase, evolution);

        // At very high evolution, occasionally throw away base and create a fresh motif
        if (evolution > 0.9 && Math.random() < 0.4) {
          state.basePhrase = createBasePhrase(density);
        }

        // Schedule all notes in this phrase
        for (const note of phraseToPlay) {
          const startTime = now + note.offsetSeconds;
          const duration = note.durationSeconds;
          const freq = Tone.Midi(note.midi).toFrequency();
          synth.triggerAttackRelease(freq, duration, startTime, note.velocity);
          effectivePhraseDuration = Math.max(
            effectivePhraseDuration,
            note.offsetSeconds + note.durationSeconds
          );
        }

        state.phraseCount += 1;
      }

      const sectionId = describeSection(state.phraseCount);
      const restDurationSeconds = restBeats * secsPerBeat;

      updateStatusText({
        scaleName: scale.name,
        phraseCount: state.phraseCount,
        section: sectionId,
        centerDegree,
        density,
        space,
        stability,
        evolution,
        bpm,
        phraseDuration: willBeSilent ? 0 : effectivePhraseDuration || 0,
        restDuration: restDurationSeconds,
        silence: willBeSilent
      });

      const totalDelay = (willBeSilent ? 0 : (effectivePhraseDuration || 0)) + restDurationSeconds;

      state.cycleTimeoutId = setTimeout(() => {
        scheduleNextCycle();
      }, totalDelay * 1000);
    }

    // -------------------------
    // Start / stop / reseed
    // -------------------------

    async function startEngine() {
      if (state.isRunning) return;
      initSynth();
      await Tone.start();

      state.isRunning = true;
      state.phraseCount = 0;
      state.basePhrase = null;
      statusText.textContent = "Starting…";

      // Randomise initial scale on start
      state.currentScaleIndex = Math.floor(Math.random() * scaleDefs.length);
      scheduleNextCycle();
    }

    function stopEngine() {
      state.isRunning = false;
      if (state.cycleTimeoutId !== null) {
        clearTimeout(state.cycleTimeoutId);
        state.cycleTimeoutId = null;
      }
      statusText.textContent = "Stopped.";
    }

    function reseedMotif() {
      // New scale + new motif
      state.currentScaleIndex = Math.floor(Math.random() * scaleDefs.length);
      state.basePhrase = null;
      state.phraseCount = 0;
      statusText.textContent += "\nMotif & scale reseeded.";
    }

    // -------------------------
    // UI bindings
    // -------------------------

    startStopBtn.addEventListener("click", () => {
      if (!state.isRunning) {
        startEngine().catch(console.error);
        startStopBtn.textContent = "Stop";
      } else {
        stopEngine();
        startStopBtn.textContent = "Start";
      }
    });

    reseedBtn.addEventListener("click", () => {
      reseedMotif();
    });

    function updateLabels() {
      bpmLabel.textContent = parseFloat(bpmSlider.value).toFixed(0);
      densityLabel.textContent = parseFloat(densitySlider.value).toFixed(2);
      spaceLabel.textContent = parseFloat(spaceSlider.value).toFixed(2);
      stabilityLabel.textContent = parseFloat(stabilitySlider.value).toFixed(2);
      evolutionLabel.textContent = parseFloat(evolutionSlider.value).toFixed(2);

      if (synth) {
        Tone.Transport.bpm.value = parseFloat(bpmSlider.value) || 70;
      }
    }

    bpmSlider.addEventListener("input", updateLabels);
    densitySlider.addEventListener("input", updateLabels);
    spaceSlider.addEventListener("input", updateLabels);
    stabilitySlider.addEventListener("input", updateLabels);
    evolutionSlider.addEventListener("input", updateLabels);

    updateLabels();
    statusText.textContent = "Idle. Press Start to begin.";

  </script>
</body>
</html>
