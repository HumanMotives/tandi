<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ikeda-Style Euclidean Generator</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    button {
      margin: 10px;
      padding: 15px 25px;
      font-size: 16px;
      background: #222;
      color: #fff;
      border: 2px solid #444;
      border-radius: 6px;
      cursor: pointer;
    }
    button:hover { border-color: #0f0; }
  </style>
</head>
<body>

  <button id="playToggle">Play</button>
  <button id="randomize">Randomize</button>

  <script>
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  let isPlaying = false, schedulerId, nextTime, step=0;

  // Euclid generator
  function euclid(steps, pulses){
    let counts=[], remainders=[pulses], divisor=steps-pulses, level=0;
    while(true){
      counts.push(Math.floor(divisor/remainders[level]));
      remainders.push(divisor%remainders[level]);
      divisor=remainders[level++];
      if(remainders[level]<=1) break;
    }
    counts.push(divisor);
    function build(l){
      if(l===-1) return [0];
      if(l===-2) return [1];
      const res=[], a=build(l-1), b=build(l-2);
      for(let i=0;i<counts[l];i++) res.push(...a);
      if(remainders[l]) res.push(...b);
      return res;
    }
    return build(level).slice(0,steps);
  }

  // Patterns + params
  let bassPat=[], tonePat=[], midPat=[], sliverPat=[];
  let toneParam = {}, midParam = {}, sliverParam = {};

  function randomizeAll(){
    // bass: sparse 4–8 steps, 1–2 hits
    const bs = 4 + Math.floor(Math.random()*5),
          bh = 1 + Math.floor(Math.random()*2);
    bassPat = euclid(bs, bh);

    // tone: 32 steps, ~1 hit per 2 bars (once every 32)
    tonePat = euclid(32,1);
    toneParam = { pitch: 600+Math.random()*800, env:0.2+Math.random()*0.2, rev:0.6+Math.random()*0.4 };

    // mid noise: 16 steps, hits 4–6, then shift by one step to land on after-beats
    midPat = euclid(16,4+Math.floor(Math.random()*3)).map((v,i)=> (i+1)%4===0 ? v:0);

    // slivers: 32 steps, hits 20–28
    const sh = 20 + Math.floor(Math.random()*9);
    sliverPat = euclid(32, sh);

    // per-sliver param
    sliverParam = { env: 0.005+Math.random()*0.01, bit: 3 + Math.floor(Math.random()*5) };
  }

  // scheduling
  function schedule(){
    const interval = 0.125; // 1/8th note = 125ms @ 120BPM
    while(nextTime < audioCtx.currentTime + 0.1){
      const idx32 = step % 32,
            idx16 = step % 16,
            idxB  = step % bassPat.length;

      // bass pulse
      if(bassPat[idxB]) triggerBass(nextTime, idxB);

      // tonal sine (very rare)
      if(tonePat[idx32]) triggerTone(nextTime);

      // mid noise on after-beat
      if(midPat[idx16]) triggerMid(nextTime);

      // ultra-fast slivers
      if(sliverPat[idx32]) triggerSliver(nextTime);

      nextTime += interval;
      step++;
    }
    schedulerId = setTimeout(schedule,25);
  }

  // generators
  function triggerBass(t, i){
    const osc = audioCtx.createOscillator(),
          g   = audioCtx.createGain(),
          freq= 80 + Math.random()*40; // low bass
    osc.frequency.value=freq;
    g.gain.setValueAtTime(0.3, t);
    g.gain.exponentialRampToValueAtTime(0.001, t+0.1);
    osc.connect(g).connect(audioCtx.destination);
    osc.start(t); osc.stop(t+0.12);
  }

  function triggerTone(t){
    const osc = audioCtx.createOscillator(),
          env = audioCtx.createGain(),
          filt= audioCtx.createBiquadFilter(),
          dly = audioCtx.createDelay(1),
          fb  = audioCtx.createGain(),
          dry = audioCtx.createGain(),
          wet = audioCtx.createGain();

    osc.type='sine';
    osc.frequency.value=toneParam.pitch;
    env.gain.setValueAtTime(0, t);
    env.gain.linearRampToValueAtTime(1,t+0.01);
    env.gain.exponentialRampToValueAtTime(0.001, t+toneParam.env);

    filt.type='lowpass'; filt.frequency.value=1000;
    dly.delayTime.value=0.3;
    fb.gain.value=0.5;
    dry.gain.value=1-toneParam.rev;
    wet.gain.value=toneParam.rev;

    osc.connect(env).connect(filt).connect(dly).connect(wet).connect(audioCtx.destination);
    filt.connect(dry).connect(audioCtx.destination);
    dly.connect(fb).connect(dly);

    osc.start(t); osc.stop(t+toneParam.env+0.1);
  }

  function triggerMid(t){
    const bufSize=256, crusher=audioCtx.createScriptProcessor(bufSize,1,1),
          step= Math.pow(0.5,4);
    crusher.onaudioprocess=e=>{
      const inp=e.inputBuffer.getChannelData(0), out=e.outputBuffer.getChannelData(0);
      for(let i=0;i<inp.length;i++) out[i]=Math.round((Math.random()*2-1)/step)*step;
    };
    const g=audioCtx.createGain();
    g.gain.setValueAtTime(0.2,t);
    g.gain.exponentialRampToValueAtTime(0.001,t+0.05);

    const src=audioCtx.createBufferSource();
    const noise=audioCtx.createBuffer(1,bufSize,audioCtx.sampleRate);
    const data=noise.getChannelData(0);
    for(let i=0;i<bufSize;i++) data[i]=Math.random()*2-1;
    src.buffer=noise;
    src.loop=true;

    src.connect(crusher).connect(g).connect(audioCtx.destination);
    src.start(t); src.stop(t+0.06);
  }

  function triggerSliver(t){
    const bufSize=128, crusher=audioCtx.createScriptProcessor(bufSize,1,1),
          step= Math.pow(0.5, sliverParam.bit);
    crusher.onaudioprocess=e=>{
      const inp=e.inputBuffer.getChannelData(0), out=e.outputBuffer.getChannelData(0);
      for(let i=0;i<inp.length;i++) out[i]=Math.round((Math.random()*2-1)/step)*step;
    };
    const g=audioCtx.createGain();
    g.gain.setValueAtTime(0.3,t);
    g.gain.exponentialRampToValueAtTime(0.001,t+sliverParam.env);

    const src=audioCtx.createBufferSource();
    const noise=audioCtx.createBuffer(1,bufSize,audioCtx.sampleRate);
    const data=noise.getChannelData(0);
    for(let i=0;i<bufSize;i++) data[i]=Math.random()*2-1;
    src.buffer=noise;
    src.loop=true;

    src.connect(crusher).connect(g).connect(audioCtx.destination);
    src.start(t); src.stop(t+sliverParam.env+0.02);
  }

  // UI
  document.getElementById('randomize').onclick = randomizeAll;
  document.getElementById('playToggle').onclick = async function(){
    if(audioCtx.state==='suspended') await audioCtx.resume();
    if(!isPlaying){
      step=0; nextTime=audioCtx.currentTime;
      randomizeAll(); schedule();
      this.textContent='Stop';
    } else {
      clearTimeout(schedulerId);
      this.textContent='Play';
    }
    isPlaying=!isPlaying;
  };

  // init
  randomizeAll();
  </script>

</body>
</html>
