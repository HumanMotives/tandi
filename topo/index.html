<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>TopoDrone V3</title>
  <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #fdf9f2; /* light cr√®me */
      overflow: hidden;
      touch-action: none;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let width, height;
function resize() {
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;
}
window.addEventListener("resize", resize);
resize();

// ---------------- AUDIO ----------------
const lines = [];
const maxLines = 6;
const baseFreq = 80;

function createLine(x) {
  const points = [];
  for (let y = 0; y <= height; y += 20) {
    const jitter = Math.random() * 20 - 10;
    points.push({ x: x + jitter, y });
  }

  const avgX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
  const rel = avgX / width;
  const freq = baseFreq * Math.pow(2, rel * 4); // spread over ~4 octaves

  const gain = new Tone.Gain(0.1).toDestination();
  const vibrato = new Tone.LFO("8n", -5, 5);
  const osc = new Tone.Oscillator(freq, "sine").connect(gain);
  vibrato.connect(osc.frequency);
  vibrato.start();
  osc.start();

  return {
    points,
    osc,
    vibrato,
    gain,
    opacity: 0.7,
    flickerDir: Math.random() > 0.5 ? 1 : -1
  };
}

function addLine(x) {
  if (lines.length >= maxLines) {
    const old = lines.shift();
    old.osc.stop();
    old.vibrato.stop();
  }
  lines.push(createLine(x));
}

// ---------------- GESTURE CONTROL ----------------
let tapTimer = 0;
let lastTapTime = 0;
let dragging = false;
let lastTouchX = null;

canvas.addEventListener("touchstart", (e) => {
  const touch = e.touches[0];
  const now = Date.now();
  if (now - lastTapTime < 300) {
    // Double tap
    addLine(touch.clientX);
    lastTapTime = 0;
  } else {
    lastTapTime = now;
    dragging = true;
    lastTouchX = touch.clientX;
  }
});

canvas.addEventListener("touchmove", (e) => {
  if (!dragging) return;
  const touch = e.touches[0];
  const dx = touch.clientX - lastTouchX;
  lastTouchX = touch.clientX;
  bendLines(touch.clientX, dx);
});

canvas.addEventListener("touchend", () => {
  dragging = false;
  lastTouchX = null;
});

// Desktop for testing
canvas.addEventListener("mousedown", (e) => {
  dragging = true;
  lastTouchX = e.clientX;
});

canvas.addEventListener("mousemove", (e) => {
  if (!dragging) return;
  const dx = e.clientX - lastTouchX;
  lastTouchX = e.clientX;
  bendLines(e.clientX, dx);
});

canvas.addEventListener("mouseup", () => {
  dragging = false;
});

// ---------------- BEND LINES ----------------
function bendLines(x, dx) {
  lines.forEach(line => {
    line.points.forEach(p => {
      const dist = Math.abs(p.x - x);
      if (dist < 100) {
        p.x += dx * 0.4 * (1 - dist / 100); // increased displacement
      }
    });
    updateAudio(line);
  });
}

function updateAudio(line) {
  const avgX = line.points.reduce((sum, p) => sum + p.x, 0) / line.points.length;
  const rel = avgX / width;
  const freq = baseFreq * Math.pow(2, rel * 4);
  line.osc.frequency.rampTo(freq, 0.1);
}

// ---------------- GYRO ----------------
if (window.DeviceOrientationEvent) {
  window.addEventListener("deviceorientation", (event) => {
    const tilt = event.gamma || 0;
    const rate = Math.max(0.1, 2 + tilt / 4);
    lines.forEach(line => {
      line.vibrato.frequency.value = rate;
    });
  });
}

// ---------------- DRAW ----------------
function draw() {
  ctx.clearRect(0, 0, width, height);

  lines.forEach(line => {
    ctx.beginPath();
    ctx.moveTo(line.points[0].x, line.points[0].y);
    line.points.forEach(p => ctx.lineTo(p.x, p.y));
    // Flickering opacity
    line.opacity += 0.003 * line.flickerDir;
    if (line.opacity > 0.9 || line.opacity < 0.6) line.flickerDir *= -1;
    ctx.strokeStyle = `rgba(102, 92, 75, ${line.opacity})`; // earthy tone
    ctx.lineWidth = 2;
    ctx.stroke();
  });

  requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>
